{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { isDirective } from './directive.js';\nimport { removeNodes } from './dom.js';\nimport { noChange, nothing } from './part.js';\nimport { TemplateInstance } from './template-instance.js';\nimport { TemplateResult } from './template-result.js';\nimport { createMarker } from './template.js';\nexport const isPrimitive = value => {\n  return value === null || !(typeof value === 'object' || typeof value === 'function');\n};\nexport const isIterable = value => {\n  return Array.isArray(value) ||\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  !!(value && value[Symbol.iterator]);\n};\n/**\n * Writes attribute values to the DOM for a group of AttributeParts bound to a\n * single attribute. The value is only set once even if there are multiple parts\n * for an attribute.\n */\nexport class AttributeCommitter {\n  constructor(element, name, strings) {\n    this.dirty = true;\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n    this.parts = [];\n    for (let i = 0; i < strings.length - 1; i++) {\n      this.parts[i] = this._createPart();\n    }\n  }\n  /**\n   * Creates a single part. Override this to create a differnt type of part.\n   */\n  _createPart() {\n    return new AttributePart(this);\n  }\n  _getValue() {\n    const strings = this.strings;\n    const l = strings.length - 1;\n    const parts = this.parts;\n    // If we're assigning an attribute via syntax like:\n    //    attr=\"${foo}\"  or  attr=${foo}\n    // but not\n    //    attr=\"${foo} ${bar}\" or attr=\"${foo} baz\"\n    // then we don't want to coerce the attribute value into one long\n    // string. Instead we want to just return the value itself directly,\n    // so that sanitizeDOMValue can get the actual value rather than\n    // String(value)\n    // The exception is if v is an array, in which case we do want to smash\n    // it together into a string without calling String() on the array.\n    //\n    // This also allows trusted values (when using TrustedTypes) being\n    // assigned to DOM sinks without being stringified in the process.\n    if (l === 1 && strings[0] === '' && strings[1] === '') {\n      const v = parts[0].value;\n      if (typeof v === 'symbol') {\n        return String(v);\n      }\n      if (typeof v === 'string' || !isIterable(v)) {\n        return v;\n      }\n    }\n    let text = '';\n    for (let i = 0; i < l; i++) {\n      text += strings[i];\n      const part = parts[i];\n      if (part !== undefined) {\n        const v = part.value;\n        if (isPrimitive(v) || !isIterable(v)) {\n          text += typeof v === 'string' ? v : String(v);\n        } else {\n          for (const t of v) {\n            text += typeof t === 'string' ? t : String(t);\n          }\n        }\n      }\n    }\n    text += strings[l];\n    return text;\n  }\n  commit() {\n    if (this.dirty) {\n      this.dirty = false;\n      this.element.setAttribute(this.name, this._getValue());\n    }\n  }\n}\n/**\n * A Part that controls all or part of an attribute value.\n */\nexport class AttributePart {\n  constructor(committer) {\n    this.value = undefined;\n    this.committer = committer;\n  }\n  setValue(value) {\n    if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {\n      this.value = value;\n      // If the value is a not a directive, dirty the committer so that it'll\n      // call setAttribute. If the value is a directive, it'll dirty the\n      // committer if it calls setValue().\n      if (!isDirective(value)) {\n        this.committer.dirty = true;\n      }\n    }\n  }\n  commit() {\n    while (isDirective(this.value)) {\n      const directive = this.value;\n      this.value = noChange;\n      directive(this);\n    }\n    if (this.value === noChange) {\n      return;\n    }\n    this.committer.commit();\n  }\n}\n/**\n * A Part that controls a location within a Node tree. Like a Range, NodePart\n * has start and end locations and can set and update the Nodes between those\n * locations.\n *\n * NodeParts support several value types: primitives, Nodes, TemplateResults,\n * as well as arrays and iterables of those types.\n */\nexport class NodePart {\n  constructor(options) {\n    this.value = undefined;\n    this.__pendingValue = undefined;\n    this.options = options;\n  }\n  /**\n   * Appends this part into a container.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  appendInto(container) {\n    this.startNode = container.appendChild(createMarker());\n    this.endNode = container.appendChild(createMarker());\n  }\n  /**\n   * Inserts this part after the `ref` node (between `ref` and `ref`'s next\n   * sibling). Both `ref` and its next sibling must be static, unchanging nodes\n   * such as those that appear in a literal section of a template.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  insertAfterNode(ref) {\n    this.startNode = ref;\n    this.endNode = ref.nextSibling;\n  }\n  /**\n   * Appends this part into a parent part.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  appendIntoPart(part) {\n    part.__insert(this.startNode = createMarker());\n    part.__insert(this.endNode = createMarker());\n  }\n  /**\n   * Inserts this part after the `ref` part.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  insertAfterPart(ref) {\n    ref.__insert(this.startNode = createMarker());\n    this.endNode = ref.endNode;\n    ref.endNode = this.startNode;\n  }\n  setValue(value) {\n    this.__pendingValue = value;\n  }\n  commit() {\n    if (this.startNode.parentNode === null) {\n      return;\n    }\n    while (isDirective(this.__pendingValue)) {\n      const directive = this.__pendingValue;\n      this.__pendingValue = noChange;\n      directive(this);\n    }\n    const value = this.__pendingValue;\n    if (value === noChange) {\n      return;\n    }\n    if (isPrimitive(value)) {\n      if (value !== this.value) {\n        this.__commitText(value);\n      }\n    } else if (value instanceof TemplateResult) {\n      this.__commitTemplateResult(value);\n    } else if (value instanceof Node) {\n      this.__commitNode(value);\n    } else if (isIterable(value)) {\n      this.__commitIterable(value);\n    } else if (value === nothing) {\n      this.value = nothing;\n      this.clear();\n    } else {\n      // Fallback, will render the string representation\n      this.__commitText(value);\n    }\n  }\n  __insert(node) {\n    this.endNode.parentNode.insertBefore(node, this.endNode);\n  }\n  __commitNode(value) {\n    if (this.value === value) {\n      return;\n    }\n    this.clear();\n    this.__insert(value);\n    this.value = value;\n  }\n  __commitText(value) {\n    const node = this.startNode.nextSibling;\n    value = value == null ? '' : value;\n    // If `value` isn't already a string, we explicitly convert it here in case\n    // it can't be implicitly converted - i.e. it's a symbol.\n    const valueAsString = typeof value === 'string' ? value : String(value);\n    if (node === this.endNode.previousSibling && node.nodeType === 3 /* Node.TEXT_NODE */) {\n      // If we only have a single text node between the markers, we can just\n      // set its value, rather than replacing it.\n      // TODO(justinfagnani): Can we just check if this.value is primitive?\n      node.data = valueAsString;\n    } else {\n      this.__commitNode(document.createTextNode(valueAsString));\n    }\n    this.value = value;\n  }\n  __commitTemplateResult(value) {\n    const template = this.options.templateFactory(value);\n    if (this.value instanceof TemplateInstance && this.value.template === template) {\n      this.value.update(value.values);\n    } else {\n      // Make sure we propagate the template processor from the TemplateResult\n      // so that we use its syntax extension, etc. The template factory comes\n      // from the render function options so that it can control template\n      // caching and preprocessing.\n      const instance = new TemplateInstance(template, value.processor, this.options);\n      const fragment = instance._clone();\n      instance.update(value.values);\n      this.__commitNode(fragment);\n      this.value = instance;\n    }\n  }\n  __commitIterable(value) {\n    // For an Iterable, we create a new InstancePart per item, then set its\n    // value to the item. This is a little bit of overhead for every item in\n    // an Iterable, but it lets us recurse easily and efficiently update Arrays\n    // of TemplateResults that will be commonly returned from expressions like:\n    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n    // If _value is an array, then the previous render was of an\n    // iterable and _value will contain the NodeParts from the previous\n    // render. If _value is not an array, clear this part and make a new\n    // array for NodeParts.\n    if (!Array.isArray(this.value)) {\n      this.value = [];\n      this.clear();\n    }\n    // Lets us keep track of how many items we stamped so we can clear leftover\n    // items from a previous render\n    const itemParts = this.value;\n    let partIndex = 0;\n    let itemPart;\n    for (const item of value) {\n      // Try to reuse an existing part\n      itemPart = itemParts[partIndex];\n      // If no existing part, create a new one\n      if (itemPart === undefined) {\n        itemPart = new NodePart(this.options);\n        itemParts.push(itemPart);\n        if (partIndex === 0) {\n          itemPart.appendIntoPart(this);\n        } else {\n          itemPart.insertAfterPart(itemParts[partIndex - 1]);\n        }\n      }\n      itemPart.setValue(item);\n      itemPart.commit();\n      partIndex++;\n    }\n    if (partIndex < itemParts.length) {\n      // Truncate the parts array so _value reflects the current state\n      itemParts.length = partIndex;\n      this.clear(itemPart && itemPart.endNode);\n    }\n  }\n  clear(startNode = this.startNode) {\n    removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\n  }\n}\n/**\n * Implements a boolean attribute, roughly as defined in the HTML\n * specification.\n *\n * If the value is truthy, then the attribute is present with a value of\n * ''. If the value is falsey, the attribute is removed.\n */\nexport class BooleanAttributePart {\n  constructor(element, name, strings) {\n    this.value = undefined;\n    this.__pendingValue = undefined;\n    if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {\n      throw new Error('Boolean attributes can only contain a single expression');\n    }\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n  }\n  setValue(value) {\n    this.__pendingValue = value;\n  }\n  commit() {\n    while (isDirective(this.__pendingValue)) {\n      const directive = this.__pendingValue;\n      this.__pendingValue = noChange;\n      directive(this);\n    }\n    if (this.__pendingValue === noChange) {\n      return;\n    }\n    const value = !!this.__pendingValue;\n    if (this.value !== value) {\n      if (value) {\n        this.element.setAttribute(this.name, '');\n      } else {\n        this.element.removeAttribute(this.name);\n      }\n      this.value = value;\n    }\n    this.__pendingValue = noChange;\n  }\n}\n/**\n * Sets attribute values for PropertyParts, so that the value is only set once\n * even if there are multiple parts for a property.\n *\n * If an expression controls the whole property value, then the value is simply\n * assigned to the property under control. If there are string literals or\n * multiple expressions, then the strings are expressions are interpolated into\n * a string first.\n */\nexport class PropertyCommitter extends AttributeCommitter {\n  constructor(element, name, strings) {\n    super(element, name, strings);\n    this.single = strings.length === 2 && strings[0] === '' && strings[1] === '';\n  }\n  _createPart() {\n    return new PropertyPart(this);\n  }\n  _getValue() {\n    if (this.single) {\n      return this.parts[0].value;\n    }\n    return super._getValue();\n  }\n  commit() {\n    if (this.dirty) {\n      this.dirty = false;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      this.element[this.name] = this._getValue();\n    }\n  }\n}\nexport class PropertyPart extends AttributePart {}\n// Detect event listener options support. If the `capture` property is read\n// from the options object, then options are supported. If not, then the third\n// argument to add/removeEventListener is interpreted as the boolean capture\n// value so we should only pass the `capture` property.\nlet eventOptionsSupported = false;\n// Wrap into an IIFE because MS Edge <= v41 does not support having try/catch\n// blocks right into the body of a module\n(() => {\n  try {\n    const options = {\n      get capture() {\n        eventOptionsSupported = true;\n        return false;\n      }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    window.addEventListener('test', options, options);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    window.removeEventListener('test', options, options);\n  } catch (_e) {\n    // event options not supported\n  }\n})();\nexport class EventPart {\n  constructor(element, eventName, eventContext) {\n    this.value = undefined;\n    this.__pendingValue = undefined;\n    this.element = element;\n    this.eventName = eventName;\n    this.eventContext = eventContext;\n    this.__boundHandleEvent = e => this.handleEvent(e);\n  }\n  setValue(value) {\n    this.__pendingValue = value;\n  }\n  commit() {\n    while (isDirective(this.__pendingValue)) {\n      const directive = this.__pendingValue;\n      this.__pendingValue = noChange;\n      directive(this);\n    }\n    if (this.__pendingValue === noChange) {\n      return;\n    }\n    const newListener = this.__pendingValue;\n    const oldListener = this.value;\n    const shouldRemoveListener = newListener == null || oldListener != null && (newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive);\n    const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);\n    if (shouldRemoveListener) {\n      this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);\n    }\n    if (shouldAddListener) {\n      this.__options = getOptions(newListener);\n      this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);\n    }\n    this.value = newListener;\n    this.__pendingValue = noChange;\n  }\n  handleEvent(event) {\n    if (typeof this.value === 'function') {\n      this.value.call(this.eventContext || this.element, event);\n    } else {\n      this.value.handleEvent(event);\n    }\n  }\n}\n// We copy options because of the inconsistent behavior of browsers when reading\n// the third argument of add/removeEventListener. IE11 doesn't support options\n// at all. Chrome 41 only reads `capture` if the argument is an object.\nconst getOptions = o => o && (eventOptionsSupported ? {\n  capture: o.capture,\n  passive: o.passive,\n  once: o.once\n} : o.capture);","map":{"version":3,"names":["isDirective","removeNodes","noChange","nothing","TemplateInstance","TemplateResult","createMarker","isPrimitive","value","isIterable","Array","isArray","Symbol","iterator","AttributeCommitter","constructor","element","name","strings","dirty","parts","i","length","_createPart","AttributePart","_getValue","l","v","String","text","part","undefined","t","commit","setAttribute","committer","setValue","directive","NodePart","options","__pendingValue","appendInto","container","startNode","appendChild","endNode","insertAfterNode","ref","nextSibling","appendIntoPart","__insert","insertAfterPart","parentNode","__commitText","__commitTemplateResult","Node","__commitNode","__commitIterable","clear","node","insertBefore","valueAsString","previousSibling","nodeType","data","document","createTextNode","template","templateFactory","update","values","instance","processor","fragment","_clone","itemParts","partIndex","itemPart","item","push","BooleanAttributePart","Error","removeAttribute","PropertyCommitter","single","PropertyPart","eventOptionsSupported","capture","window","addEventListener","removeEventListener","_e","EventPart","eventName","eventContext","__boundHandleEvent","e","handleEvent","newListener","oldListener","shouldRemoveListener","once","passive","shouldAddListener","__options","getOptions","event","call","o"],"sources":["D:\\my code\\my-app\\node_modules\\lit-html\\src\\lib\\parts.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {isDirective} from './directive.js';\nimport {removeNodes} from './dom.js';\nimport {noChange, nothing, Part} from './part.js';\nimport {RenderOptions} from './render-options.js';\nimport {TemplateInstance} from './template-instance.js';\nimport {TemplateResult} from './template-result.js';\nimport {createMarker} from './template.js';\n\n// https://tc39.github.io/ecma262/#sec-typeof-operator\nexport type Primitive = null|undefined|boolean|number|string|symbol|bigint;\nexport const isPrimitive = (value: unknown): value is Primitive => {\n  return (\n      value === null ||\n      !(typeof value === 'object' || typeof value === 'function'));\n};\nexport const isIterable = (value: unknown): value is Iterable<unknown> => {\n  return Array.isArray(value) ||\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      !!(value && (value as any)[Symbol.iterator]);\n};\n\n/**\n * Writes attribute values to the DOM for a group of AttributeParts bound to a\n * single attribute. The value is only set once even if there are multiple parts\n * for an attribute.\n */\nexport class AttributeCommitter {\n  readonly element: Element;\n  readonly name: string;\n  readonly strings: ReadonlyArray<string>;\n  readonly parts: ReadonlyArray<AttributePart>;\n  dirty = true;\n\n  constructor(element: Element, name: string, strings: ReadonlyArray<string>) {\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n    this.parts = [];\n    for (let i = 0; i < strings.length - 1; i++) {\n      (this.parts as AttributePart[])[i] = this._createPart();\n    }\n  }\n\n  /**\n   * Creates a single part. Override this to create a differnt type of part.\n   */\n  protected _createPart(): AttributePart {\n    return new AttributePart(this);\n  }\n\n  protected _getValue(): unknown {\n    const strings = this.strings;\n    const l = strings.length - 1;\n    const parts = this.parts;\n\n    // If we're assigning an attribute via syntax like:\n    //    attr=\"${foo}\"  or  attr=${foo}\n    // but not\n    //    attr=\"${foo} ${bar}\" or attr=\"${foo} baz\"\n    // then we don't want to coerce the attribute value into one long\n    // string. Instead we want to just return the value itself directly,\n    // so that sanitizeDOMValue can get the actual value rather than\n    // String(value)\n    // The exception is if v is an array, in which case we do want to smash\n    // it together into a string without calling String() on the array.\n    //\n    // This also allows trusted values (when using TrustedTypes) being\n    // assigned to DOM sinks without being stringified in the process.\n    if (l === 1 && strings[0] === '' && strings[1] === '') {\n      const v = parts[0].value;\n      if (typeof v === 'symbol') {\n        return String(v);\n      }\n      if (typeof v === 'string' || !isIterable(v)) {\n        return v;\n      }\n    }\n    let text = '';\n\n    for (let i = 0; i < l; i++) {\n      text += strings[i];\n      const part = parts[i];\n      if (part !== undefined) {\n        const v = part.value;\n        if (isPrimitive(v) || !isIterable(v)) {\n          text += typeof v === 'string' ? v : String(v);\n        } else {\n          for (const t of v) {\n            text += typeof t === 'string' ? t : String(t);\n          }\n        }\n      }\n    }\n\n    text += strings[l];\n    return text;\n  }\n\n  commit(): void {\n    if (this.dirty) {\n      this.dirty = false;\n      this.element.setAttribute(this.name, this._getValue() as string);\n    }\n  }\n}\n\n/**\n * A Part that controls all or part of an attribute value.\n */\nexport class AttributePart implements Part {\n  readonly committer: AttributeCommitter;\n  value: unknown = undefined;\n\n  constructor(committer: AttributeCommitter) {\n    this.committer = committer;\n  }\n\n  setValue(value: unknown): void {\n    if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {\n      this.value = value;\n      // If the value is a not a directive, dirty the committer so that it'll\n      // call setAttribute. If the value is a directive, it'll dirty the\n      // committer if it calls setValue().\n      if (!isDirective(value)) {\n        this.committer.dirty = true;\n      }\n    }\n  }\n\n  commit() {\n    while (isDirective(this.value)) {\n      const directive = this.value;\n      this.value = noChange;\n      directive(this);\n    }\n    if (this.value === noChange) {\n      return;\n    }\n    this.committer.commit();\n  }\n}\n\n/**\n * A Part that controls a location within a Node tree. Like a Range, NodePart\n * has start and end locations and can set and update the Nodes between those\n * locations.\n *\n * NodeParts support several value types: primitives, Nodes, TemplateResults,\n * as well as arrays and iterables of those types.\n */\nexport class NodePart implements Part {\n  readonly options: RenderOptions;\n  startNode!: Node;\n  endNode!: Node;\n  value: unknown = undefined;\n  private __pendingValue: unknown = undefined;\n\n  constructor(options: RenderOptions) {\n    this.options = options;\n  }\n\n  /**\n   * Appends this part into a container.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  appendInto(container: Node) {\n    this.startNode = container.appendChild(createMarker());\n    this.endNode = container.appendChild(createMarker());\n  }\n\n  /**\n   * Inserts this part after the `ref` node (between `ref` and `ref`'s next\n   * sibling). Both `ref` and its next sibling must be static, unchanging nodes\n   * such as those that appear in a literal section of a template.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  insertAfterNode(ref: Node) {\n    this.startNode = ref;\n    this.endNode = ref.nextSibling!;\n  }\n\n  /**\n   * Appends this part into a parent part.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  appendIntoPart(part: NodePart) {\n    part.__insert(this.startNode = createMarker());\n    part.__insert(this.endNode = createMarker());\n  }\n\n  /**\n   * Inserts this part after the `ref` part.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  insertAfterPart(ref: NodePart) {\n    ref.__insert(this.startNode = createMarker());\n    this.endNode = ref.endNode;\n    ref.endNode = this.startNode;\n  }\n\n  setValue(value: unknown): void {\n    this.__pendingValue = value;\n  }\n\n  commit() {\n    if (this.startNode.parentNode === null) {\n      return;\n    }\n    while (isDirective(this.__pendingValue)) {\n      const directive = this.__pendingValue;\n      this.__pendingValue = noChange;\n      directive(this);\n    }\n    const value = this.__pendingValue;\n    if (value === noChange) {\n      return;\n    }\n    if (isPrimitive(value)) {\n      if (value !== this.value) {\n        this.__commitText(value);\n      }\n    } else if (value instanceof TemplateResult) {\n      this.__commitTemplateResult(value);\n    } else if (value instanceof Node) {\n      this.__commitNode(value);\n    } else if (isIterable(value)) {\n      this.__commitIterable(value);\n    } else if (value === nothing) {\n      this.value = nothing;\n      this.clear();\n    } else {\n      // Fallback, will render the string representation\n      this.__commitText(value);\n    }\n  }\n\n  private __insert(node: Node) {\n    this.endNode.parentNode!.insertBefore(node, this.endNode);\n  }\n\n  private __commitNode(value: Node): void {\n    if (this.value === value) {\n      return;\n    }\n    this.clear();\n    this.__insert(value);\n    this.value = value;\n  }\n\n  private __commitText(value: unknown): void {\n    const node = this.startNode.nextSibling!;\n    value = value == null ? '' : value;\n    // If `value` isn't already a string, we explicitly convert it here in case\n    // it can't be implicitly converted - i.e. it's a symbol.\n    const valueAsString: string =\n        typeof value === 'string' ? value : String(value);\n    if (node === this.endNode.previousSibling &&\n        node.nodeType === 3 /* Node.TEXT_NODE */) {\n      // If we only have a single text node between the markers, we can just\n      // set its value, rather than replacing it.\n      // TODO(justinfagnani): Can we just check if this.value is primitive?\n      (node as Text).data = valueAsString;\n    } else {\n      this.__commitNode(document.createTextNode(valueAsString));\n    }\n    this.value = value;\n  }\n\n  private __commitTemplateResult(value: TemplateResult): void {\n    const template = this.options.templateFactory(value);\n    if (this.value instanceof TemplateInstance &&\n        this.value.template === template) {\n      this.value.update(value.values);\n    } else {\n      // Make sure we propagate the template processor from the TemplateResult\n      // so that we use its syntax extension, etc. The template factory comes\n      // from the render function options so that it can control template\n      // caching and preprocessing.\n      const instance =\n          new TemplateInstance(template, value.processor, this.options);\n      const fragment = instance._clone();\n      instance.update(value.values);\n      this.__commitNode(fragment);\n      this.value = instance;\n    }\n  }\n\n  private __commitIterable(value: Iterable<unknown>): void {\n    // For an Iterable, we create a new InstancePart per item, then set its\n    // value to the item. This is a little bit of overhead for every item in\n    // an Iterable, but it lets us recurse easily and efficiently update Arrays\n    // of TemplateResults that will be commonly returned from expressions like:\n    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n\n    // If _value is an array, then the previous render was of an\n    // iterable and _value will contain the NodeParts from the previous\n    // render. If _value is not an array, clear this part and make a new\n    // array for NodeParts.\n    if (!Array.isArray(this.value)) {\n      this.value = [];\n      this.clear();\n    }\n\n    // Lets us keep track of how many items we stamped so we can clear leftover\n    // items from a previous render\n    const itemParts = this.value as NodePart[];\n    let partIndex = 0;\n    let itemPart: NodePart|undefined;\n\n    for (const item of value) {\n      // Try to reuse an existing part\n      itemPart = itemParts[partIndex];\n\n      // If no existing part, create a new one\n      if (itemPart === undefined) {\n        itemPart = new NodePart(this.options);\n        itemParts.push(itemPart);\n        if (partIndex === 0) {\n          itemPart.appendIntoPart(this);\n        } else {\n          itemPart.insertAfterPart(itemParts[partIndex - 1]);\n        }\n      }\n      itemPart.setValue(item);\n      itemPart.commit();\n      partIndex++;\n    }\n\n    if (partIndex < itemParts.length) {\n      // Truncate the parts array so _value reflects the current state\n      itemParts.length = partIndex;\n      this.clear(itemPart && itemPart.endNode);\n    }\n  }\n\n  clear(startNode: Node = this.startNode) {\n    removeNodes(\n        this.startNode.parentNode!, startNode.nextSibling!, this.endNode);\n  }\n}\n\n/**\n * Implements a boolean attribute, roughly as defined in the HTML\n * specification.\n *\n * If the value is truthy, then the attribute is present with a value of\n * ''. If the value is falsey, the attribute is removed.\n */\nexport class BooleanAttributePart implements Part {\n  readonly element: Element;\n  readonly name: string;\n  readonly strings: readonly string[];\n  value: unknown = undefined;\n  private __pendingValue: unknown = undefined;\n\n  constructor(element: Element, name: string, strings: readonly string[]) {\n    if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {\n      throw new Error(\n          'Boolean attributes can only contain a single expression');\n    }\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n  }\n\n  setValue(value: unknown): void {\n    this.__pendingValue = value;\n  }\n\n  commit() {\n    while (isDirective(this.__pendingValue)) {\n      const directive = this.__pendingValue;\n      this.__pendingValue = noChange;\n      directive(this);\n    }\n    if (this.__pendingValue === noChange) {\n      return;\n    }\n    const value = !!this.__pendingValue;\n    if (this.value !== value) {\n      if (value) {\n        this.element.setAttribute(this.name, '');\n      } else {\n        this.element.removeAttribute(this.name);\n      }\n      this.value = value;\n    }\n    this.__pendingValue = noChange;\n  }\n}\n\n/**\n * Sets attribute values for PropertyParts, so that the value is only set once\n * even if there are multiple parts for a property.\n *\n * If an expression controls the whole property value, then the value is simply\n * assigned to the property under control. If there are string literals or\n * multiple expressions, then the strings are expressions are interpolated into\n * a string first.\n */\nexport class PropertyCommitter extends AttributeCommitter {\n  readonly single: boolean;\n\n  constructor(element: Element, name: string, strings: ReadonlyArray<string>) {\n    super(element, name, strings);\n    this.single =\n        (strings.length === 2 && strings[0] === '' && strings[1] === '');\n  }\n\n  protected _createPart(): PropertyPart {\n    return new PropertyPart(this);\n  }\n\n  protected _getValue() {\n    if (this.single) {\n      return this.parts[0].value;\n    }\n    return super._getValue();\n  }\n\n  commit(): void {\n    if (this.dirty) {\n      this.dirty = false;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (this.element as any)[this.name] = this._getValue();\n    }\n  }\n}\n\nexport class PropertyPart extends AttributePart {}\n\n// Detect event listener options support. If the `capture` property is read\n// from the options object, then options are supported. If not, then the third\n// argument to add/removeEventListener is interpreted as the boolean capture\n// value so we should only pass the `capture` property.\nlet eventOptionsSupported = false;\n\n// Wrap into an IIFE because MS Edge <= v41 does not support having try/catch\n// blocks right into the body of a module\n(() => {\n  try {\n    const options = {\n      get capture() {\n        eventOptionsSupported = true;\n        return false;\n      }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    window.addEventListener('test', options as any, options);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    window.removeEventListener('test', options as any, options);\n  } catch (_e) {\n    // event options not supported\n  }\n})();\n\ntype EventHandlerWithOptions =\n    EventListenerOrEventListenerObject&Partial<AddEventListenerOptions>;\nexport class EventPart implements Part {\n  readonly element: Element;\n  readonly eventName: string;\n  readonly eventContext?: EventTarget;\n  value: undefined|EventHandlerWithOptions = undefined;\n  private __options?: AddEventListenerOptions;\n  private __pendingValue: undefined|EventHandlerWithOptions = undefined;\n  private readonly __boundHandleEvent: (event: Event) => void;\n\n  constructor(element: Element, eventName: string, eventContext?: EventTarget) {\n    this.element = element;\n    this.eventName = eventName;\n    this.eventContext = eventContext;\n    this.__boundHandleEvent = (e) => this.handleEvent(e);\n  }\n\n  setValue(value: undefined|EventHandlerWithOptions): void {\n    this.__pendingValue = value;\n  }\n\n  commit() {\n    while (isDirective(this.__pendingValue)) {\n      const directive = this.__pendingValue;\n      this.__pendingValue = noChange as EventHandlerWithOptions;\n      directive(this);\n    }\n    if (this.__pendingValue === noChange) {\n      return;\n    }\n\n    const newListener = this.__pendingValue;\n    const oldListener = this.value;\n    const shouldRemoveListener = newListener == null ||\n        oldListener != null &&\n            (newListener.capture !== oldListener.capture ||\n             newListener.once !== oldListener.once ||\n             newListener.passive !== oldListener.passive);\n    const shouldAddListener =\n        newListener != null && (oldListener == null || shouldRemoveListener);\n\n    if (shouldRemoveListener) {\n      this.element.removeEventListener(\n          this.eventName, this.__boundHandleEvent, this.__options);\n    }\n    if (shouldAddListener) {\n      this.__options = getOptions(newListener);\n      this.element.addEventListener(\n          this.eventName, this.__boundHandleEvent, this.__options);\n    }\n    this.value = newListener;\n    this.__pendingValue = noChange as EventHandlerWithOptions;\n  }\n\n  handleEvent(event: Event) {\n    if (typeof this.value === 'function') {\n      this.value.call(this.eventContext || this.element, event);\n    } else {\n      (this.value as EventListenerObject).handleEvent(event);\n    }\n  }\n}\n\n// We copy options because of the inconsistent behavior of browsers when reading\n// the third argument of add/removeEventListener. IE11 doesn't support options\n// at all. Chrome 41 only reads `capture` if the argument is an object.\nconst getOptions = (o: AddEventListenerOptions|undefined) => o &&\n    (eventOptionsSupported ?\n         {capture: o.capture, passive: o.passive, once: o.once} :\n         o.capture as AddEventListenerOptions);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}