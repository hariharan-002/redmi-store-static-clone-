{"ast":null,"code":"// Generated by CoffeeScript 1.12.4\nvar Inline, ParseException, ParseMore, Parser, Pattern, Utils;\nInline = require('./Inline');\nPattern = require('./Pattern');\nUtils = require('./Utils');\nParseException = require('./Exception/ParseException');\nParseMore = require('./Exception/ParseMore');\nParser = function () {\n  Parser.prototype.PATTERN_FOLDED_SCALAR_ALL = new Pattern('^(?:(?<type>![^\\\\|>]*)\\\\s+)?(?<separator>\\\\||>)(?<modifiers>\\\\+|\\\\-|\\\\d+|\\\\+\\\\d+|\\\\-\\\\d+|\\\\d+\\\\+|\\\\d+\\\\-)?(?<comments> +#.*)?$');\n  Parser.prototype.PATTERN_FOLDED_SCALAR_END = new Pattern('(?<separator>\\\\||>)(?<modifiers>\\\\+|\\\\-|\\\\d+|\\\\+\\\\d+|\\\\-\\\\d+|\\\\d+\\\\+|\\\\d+\\\\-)?(?<comments> +#.*)?$');\n  Parser.prototype.PATTERN_SEQUENCE_ITEM = new Pattern('^\\\\-((?<leadspaces>\\\\s+)(?<value>.+?))?\\\\s*$');\n  Parser.prototype.PATTERN_ANCHOR_VALUE = new Pattern('^&(?<ref>[^ ]+) *(?<value>.*)');\n  Parser.prototype.PATTERN_COMPACT_NOTATION = new Pattern('^(?<key>' + Inline.REGEX_QUOTED_STRING + '|[^ \\'\"\\\\{\\\\[].*?) *\\\\:(\\\\s+(?<value>.+?))?\\\\s*$');\n  Parser.prototype.PATTERN_MAPPING_ITEM = new Pattern('^(?<key>' + Inline.REGEX_QUOTED_STRING + '|[^ \\'\"\\\\[\\\\{].*?) *\\\\:(\\\\s+(?<value>.+?))?\\\\s*$');\n  Parser.prototype.PATTERN_DECIMAL = new Pattern('\\\\d+');\n  Parser.prototype.PATTERN_INDENT_SPACES = new Pattern('^ +');\n  Parser.prototype.PATTERN_TRAILING_LINES = new Pattern('(\\n*)$');\n  Parser.prototype.PATTERN_YAML_HEADER = new Pattern('^\\\\%YAML[: ][\\\\d\\\\.]+.*\\n', 'm');\n  Parser.prototype.PATTERN_LEADING_COMMENTS = new Pattern('^(\\\\#.*?\\n)+', 'm');\n  Parser.prototype.PATTERN_DOCUMENT_MARKER_START = new Pattern('^\\\\-\\\\-\\\\-.*?\\n', 'm');\n  Parser.prototype.PATTERN_DOCUMENT_MARKER_END = new Pattern('^\\\\.\\\\.\\\\.\\\\s*$', 'm');\n  Parser.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION = {};\n  Parser.prototype.CONTEXT_NONE = 0;\n  Parser.prototype.CONTEXT_SEQUENCE = 1;\n  Parser.prototype.CONTEXT_MAPPING = 2;\n  function Parser(offset) {\n    this.offset = offset != null ? offset : 0;\n    this.lines = [];\n    this.currentLineNb = -1;\n    this.currentLine = '';\n    this.refs = {};\n  }\n  Parser.prototype.parse = function (value, exceptionOnInvalidType, objectDecoder) {\n    var alias, allowOverwrite, block, c, context, data, e, first, i, indent, isRef, j, k, key, l, lastKey, len, len1, len2, len3, lineCount, m, matches, mergeNode, n, name, parsed, parsedItem, parser, ref, ref1, ref2, refName, refValue, val, values;\n    if (exceptionOnInvalidType == null) {\n      exceptionOnInvalidType = false;\n    }\n    if (objectDecoder == null) {\n      objectDecoder = null;\n    }\n    this.currentLineNb = -1;\n    this.currentLine = '';\n    this.lines = this.cleanup(value).split(\"\\n\");\n    data = null;\n    context = this.CONTEXT_NONE;\n    allowOverwrite = false;\n    while (this.moveToNextLine()) {\n      if (this.isCurrentLineEmpty()) {\n        continue;\n      }\n      if (\"\\t\" === this.currentLine[0]) {\n        throw new ParseException('A YAML file cannot contain tabs as indentation.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n      isRef = mergeNode = false;\n      if (values = this.PATTERN_SEQUENCE_ITEM.exec(this.currentLine)) {\n        if (this.CONTEXT_MAPPING === context) {\n          throw new ParseException('You cannot define a sequence item when in a mapping');\n        }\n        context = this.CONTEXT_SEQUENCE;\n        if (data == null) {\n          data = [];\n        }\n        if (values.value != null && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {\n          isRef = matches.ref;\n          values.value = matches.value;\n        }\n        if (!(values.value != null) || '' === Utils.trim(values.value, ' ') || Utils.ltrim(values.value, ' ').indexOf('#') === 0) {\n          if (this.currentLineNb < this.lines.length - 1 && !this.isNextLineUnIndentedCollection()) {\n            c = this.getRealCurrentLineNb() + 1;\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            data.push(parser.parse(this.getNextEmbedBlock(null, true), exceptionOnInvalidType, objectDecoder));\n          } else {\n            data.push(null);\n          }\n        } else {\n          if (((ref = values.leadspaces) != null ? ref.length : void 0) && (matches = this.PATTERN_COMPACT_NOTATION.exec(values.value))) {\n            c = this.getRealCurrentLineNb();\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            block = values.value;\n            indent = this.getCurrentLineIndentation();\n            if (this.isNextLineIndented(false)) {\n              block += \"\\n\" + this.getNextEmbedBlock(indent + values.leadspaces.length + 1, true);\n            }\n            data.push(parser.parse(block, exceptionOnInvalidType, objectDecoder));\n          } else {\n            data.push(this.parseValue(values.value, exceptionOnInvalidType, objectDecoder));\n          }\n        }\n      } else if ((values = this.PATTERN_MAPPING_ITEM.exec(this.currentLine)) && values.key.indexOf(' #') === -1) {\n        if (this.CONTEXT_SEQUENCE === context) {\n          throw new ParseException('You cannot define a mapping item when in a sequence');\n        }\n        context = this.CONTEXT_MAPPING;\n        if (data == null) {\n          data = {};\n        }\n        Inline.configure(exceptionOnInvalidType, objectDecoder);\n        try {\n          key = Inline.parseScalar(values.key);\n        } catch (error) {\n          e = error;\n          e.parsedLine = this.getRealCurrentLineNb() + 1;\n          e.snippet = this.currentLine;\n          throw e;\n        }\n        if ('<<' === key) {\n          mergeNode = true;\n          allowOverwrite = true;\n          if (((ref1 = values.value) != null ? ref1.indexOf('*') : void 0) === 0) {\n            refName = values.value.slice(1);\n            if (this.refs[refName] == null) {\n              throw new ParseException('Reference \"' + refName + '\" does not exist.', this.getRealCurrentLineNb() + 1, this.currentLine);\n            }\n            refValue = this.refs[refName];\n            if (typeof refValue !== 'object') {\n              throw new ParseException('YAML merge keys used with a scalar value instead of an object.', this.getRealCurrentLineNb() + 1, this.currentLine);\n            }\n            if (refValue instanceof Array) {\n              for (i = j = 0, len = refValue.length; j < len; i = ++j) {\n                value = refValue[i];\n                if (data[name = String(i)] == null) {\n                  data[name] = value;\n                }\n              }\n            } else {\n              for (key in refValue) {\n                value = refValue[key];\n                if (data[key] == null) {\n                  data[key] = value;\n                }\n              }\n            }\n          } else {\n            if (values.value != null && values.value !== '') {\n              value = values.value;\n            } else {\n              value = this.getNextEmbedBlock();\n            }\n            c = this.getRealCurrentLineNb() + 1;\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            parsed = parser.parse(value, exceptionOnInvalidType);\n            if (typeof parsed !== 'object') {\n              throw new ParseException('YAML merge keys used with a scalar value instead of an object.', this.getRealCurrentLineNb() + 1, this.currentLine);\n            }\n            if (parsed instanceof Array) {\n              for (l = 0, len1 = parsed.length; l < len1; l++) {\n                parsedItem = parsed[l];\n                if (typeof parsedItem !== 'object') {\n                  throw new ParseException('Merge items must be objects.', this.getRealCurrentLineNb() + 1, parsedItem);\n                }\n                if (parsedItem instanceof Array) {\n                  for (i = m = 0, len2 = parsedItem.length; m < len2; i = ++m) {\n                    value = parsedItem[i];\n                    k = String(i);\n                    if (!data.hasOwnProperty(k)) {\n                      data[k] = value;\n                    }\n                  }\n                } else {\n                  for (key in parsedItem) {\n                    value = parsedItem[key];\n                    if (!data.hasOwnProperty(key)) {\n                      data[key] = value;\n                    }\n                  }\n                }\n              }\n            } else {\n              for (key in parsed) {\n                value = parsed[key];\n                if (!data.hasOwnProperty(key)) {\n                  data[key] = value;\n                }\n              }\n            }\n          }\n        } else if (values.value != null && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {\n          isRef = matches.ref;\n          values.value = matches.value;\n        }\n        if (mergeNode) {} else if (!(values.value != null) || '' === Utils.trim(values.value, ' ') || Utils.ltrim(values.value, ' ').indexOf('#') === 0) {\n          if (!this.isNextLineIndented() && !this.isNextLineUnIndentedCollection()) {\n            if (allowOverwrite || data[key] === void 0) {\n              data[key] = null;\n            }\n          } else {\n            c = this.getRealCurrentLineNb() + 1;\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            val = parser.parse(this.getNextEmbedBlock(), exceptionOnInvalidType, objectDecoder);\n            if (allowOverwrite || data[key] === void 0) {\n              data[key] = val;\n            }\n          }\n        } else {\n          val = this.parseValue(values.value, exceptionOnInvalidType, objectDecoder);\n          if (allowOverwrite || data[key] === void 0) {\n            data[key] = val;\n          }\n        }\n      } else {\n        lineCount = this.lines.length;\n        if (1 === lineCount || 2 === lineCount && Utils.isEmpty(this.lines[1])) {\n          try {\n            value = Inline.parse(this.lines[0], exceptionOnInvalidType, objectDecoder);\n          } catch (error) {\n            e = error;\n            e.parsedLine = this.getRealCurrentLineNb() + 1;\n            e.snippet = this.currentLine;\n            throw e;\n          }\n          if (typeof value === 'object') {\n            if (value instanceof Array) {\n              first = value[0];\n            } else {\n              for (key in value) {\n                first = value[key];\n                break;\n              }\n            }\n            if (typeof first === 'string' && first.indexOf('*') === 0) {\n              data = [];\n              for (n = 0, len3 = value.length; n < len3; n++) {\n                alias = value[n];\n                data.push(this.refs[alias.slice(1)]);\n              }\n              value = data;\n            }\n          }\n          return value;\n        } else if ((ref2 = Utils.ltrim(value).charAt(0)) === '[' || ref2 === '{') {\n          try {\n            return Inline.parse(value, exceptionOnInvalidType, objectDecoder);\n          } catch (error) {\n            e = error;\n            e.parsedLine = this.getRealCurrentLineNb() + 1;\n            e.snippet = this.currentLine;\n            throw e;\n          }\n        }\n        throw new ParseException('Unable to parse.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n      if (isRef) {\n        if (data instanceof Array) {\n          this.refs[isRef] = data[data.length - 1];\n        } else {\n          lastKey = null;\n          for (key in data) {\n            lastKey = key;\n          }\n          this.refs[isRef] = data[lastKey];\n        }\n      }\n    }\n    if (Utils.isEmpty(data)) {\n      return null;\n    } else {\n      return data;\n    }\n  };\n  Parser.prototype.getRealCurrentLineNb = function () {\n    return this.currentLineNb + this.offset;\n  };\n  Parser.prototype.getCurrentLineIndentation = function () {\n    return this.currentLine.length - Utils.ltrim(this.currentLine, ' ').length;\n  };\n  Parser.prototype.getNextEmbedBlock = function (indentation, includeUnindentedCollection) {\n    var data, indent, isItUnindentedCollection, newIndent, removeComments, removeCommentsPattern, unindentedEmbedBlock;\n    if (indentation == null) {\n      indentation = null;\n    }\n    if (includeUnindentedCollection == null) {\n      includeUnindentedCollection = false;\n    }\n    this.moveToNextLine();\n    if (indentation == null) {\n      newIndent = this.getCurrentLineIndentation();\n      unindentedEmbedBlock = this.isStringUnIndentedCollectionItem(this.currentLine);\n      if (!this.isCurrentLineEmpty() && 0 === newIndent && !unindentedEmbedBlock) {\n        throw new ParseException('Indentation problem.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n    } else {\n      newIndent = indentation;\n    }\n    data = [this.currentLine.slice(newIndent)];\n    if (!includeUnindentedCollection) {\n      isItUnindentedCollection = this.isStringUnIndentedCollectionItem(this.currentLine);\n    }\n    removeCommentsPattern = this.PATTERN_FOLDED_SCALAR_END;\n    removeComments = !removeCommentsPattern.test(this.currentLine);\n    while (this.moveToNextLine()) {\n      indent = this.getCurrentLineIndentation();\n      if (indent === newIndent) {\n        removeComments = !removeCommentsPattern.test(this.currentLine);\n      }\n      if (removeComments && this.isCurrentLineComment()) {\n        continue;\n      }\n      if (this.isCurrentLineBlank()) {\n        data.push(this.currentLine.slice(newIndent));\n        continue;\n      }\n      if (isItUnindentedCollection && !this.isStringUnIndentedCollectionItem(this.currentLine) && indent === newIndent) {\n        this.moveToPreviousLine();\n        break;\n      }\n      if (indent >= newIndent) {\n        data.push(this.currentLine.slice(newIndent));\n      } else if (Utils.ltrim(this.currentLine).charAt(0) === '#') {} else if (0 === indent) {\n        this.moveToPreviousLine();\n        break;\n      } else {\n        throw new ParseException('Indentation problem.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n    }\n    return data.join(\"\\n\");\n  };\n  Parser.prototype.moveToNextLine = function () {\n    if (this.currentLineNb >= this.lines.length - 1) {\n      return false;\n    }\n    this.currentLine = this.lines[++this.currentLineNb];\n    return true;\n  };\n  Parser.prototype.moveToPreviousLine = function () {\n    this.currentLine = this.lines[--this.currentLineNb];\n  };\n  Parser.prototype.parseValue = function (value, exceptionOnInvalidType, objectDecoder) {\n    var e, foldedIndent, matches, modifiers, pos, ref, ref1, val;\n    if (0 === value.indexOf('*')) {\n      pos = value.indexOf('#');\n      if (pos !== -1) {\n        value = value.substr(1, pos - 2);\n      } else {\n        value = value.slice(1);\n      }\n      if (this.refs[value] === void 0) {\n        throw new ParseException('Reference \"' + value + '\" does not exist.', this.currentLine);\n      }\n      return this.refs[value];\n    }\n    if (matches = this.PATTERN_FOLDED_SCALAR_ALL.exec(value)) {\n      modifiers = (ref = matches.modifiers) != null ? ref : '';\n      foldedIndent = Math.abs(parseInt(modifiers));\n      if (isNaN(foldedIndent)) {\n        foldedIndent = 0;\n      }\n      val = this.parseFoldedScalar(matches.separator, this.PATTERN_DECIMAL.replace(modifiers, ''), foldedIndent);\n      if (matches.type != null) {\n        Inline.configure(exceptionOnInvalidType, objectDecoder);\n        return Inline.parseScalar(matches.type + ' ' + val);\n      } else {\n        return val;\n      }\n    }\n    if ((ref1 = value.charAt(0)) === '[' || ref1 === '{' || ref1 === '\"' || ref1 === \"'\") {\n      while (true) {\n        try {\n          return Inline.parse(value, exceptionOnInvalidType, objectDecoder);\n        } catch (error) {\n          e = error;\n          if (e instanceof ParseMore && this.moveToNextLine()) {\n            value += \"\\n\" + Utils.trim(this.currentLine, ' ');\n          } else {\n            e.parsedLine = this.getRealCurrentLineNb() + 1;\n            e.snippet = this.currentLine;\n            throw e;\n          }\n        }\n      }\n    } else {\n      if (this.isNextLineIndented()) {\n        value += \"\\n\" + this.getNextEmbedBlock();\n      }\n      return Inline.parse(value, exceptionOnInvalidType, objectDecoder);\n    }\n  };\n  Parser.prototype.parseFoldedScalar = function (separator, indicator, indentation) {\n    var isCurrentLineBlank, j, len, line, matches, newText, notEOF, pattern, ref, text;\n    if (indicator == null) {\n      indicator = '';\n    }\n    if (indentation == null) {\n      indentation = 0;\n    }\n    notEOF = this.moveToNextLine();\n    if (!notEOF) {\n      return '';\n    }\n    isCurrentLineBlank = this.isCurrentLineBlank();\n    text = '';\n    while (notEOF && isCurrentLineBlank) {\n      if (notEOF = this.moveToNextLine()) {\n        text += \"\\n\";\n        isCurrentLineBlank = this.isCurrentLineBlank();\n      }\n    }\n    if (0 === indentation) {\n      if (matches = this.PATTERN_INDENT_SPACES.exec(this.currentLine)) {\n        indentation = matches[0].length;\n      }\n    }\n    if (indentation > 0) {\n      pattern = this.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation];\n      if (pattern == null) {\n        pattern = new Pattern('^ {' + indentation + '}(.*)$');\n        Parser.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation] = pattern;\n      }\n      while (notEOF && (isCurrentLineBlank || (matches = pattern.exec(this.currentLine)))) {\n        if (isCurrentLineBlank) {\n          text += this.currentLine.slice(indentation);\n        } else {\n          text += matches[1];\n        }\n        if (notEOF = this.moveToNextLine()) {\n          text += \"\\n\";\n          isCurrentLineBlank = this.isCurrentLineBlank();\n        }\n      }\n    } else if (notEOF) {\n      text += \"\\n\";\n    }\n    if (notEOF) {\n      this.moveToPreviousLine();\n    }\n    if ('>' === separator) {\n      newText = '';\n      ref = text.split(\"\\n\");\n      for (j = 0, len = ref.length; j < len; j++) {\n        line = ref[j];\n        if (line.length === 0 || line.charAt(0) === ' ') {\n          newText = Utils.rtrim(newText, ' ') + line + \"\\n\";\n        } else {\n          newText += line + ' ';\n        }\n      }\n      text = newText;\n    }\n    if ('+' !== indicator) {\n      text = Utils.rtrim(text);\n    }\n    if ('' === indicator) {\n      text = this.PATTERN_TRAILING_LINES.replace(text, \"\\n\");\n    } else if ('-' === indicator) {\n      text = this.PATTERN_TRAILING_LINES.replace(text, '');\n    }\n    return text;\n  };\n  Parser.prototype.isNextLineIndented = function (ignoreComments) {\n    var EOF, currentIndentation, ret;\n    if (ignoreComments == null) {\n      ignoreComments = true;\n    }\n    currentIndentation = this.getCurrentLineIndentation();\n    EOF = !this.moveToNextLine();\n    if (ignoreComments) {\n      while (!EOF && this.isCurrentLineEmpty()) {\n        EOF = !this.moveToNextLine();\n      }\n    } else {\n      while (!EOF && this.isCurrentLineBlank()) {\n        EOF = !this.moveToNextLine();\n      }\n    }\n    if (EOF) {\n      return false;\n    }\n    ret = false;\n    if (this.getCurrentLineIndentation() > currentIndentation) {\n      ret = true;\n    }\n    this.moveToPreviousLine();\n    return ret;\n  };\n  Parser.prototype.isCurrentLineEmpty = function () {\n    var trimmedLine;\n    trimmedLine = Utils.trim(this.currentLine, ' ');\n    return trimmedLine.length === 0 || trimmedLine.charAt(0) === '#';\n  };\n  Parser.prototype.isCurrentLineBlank = function () {\n    return '' === Utils.trim(this.currentLine, ' ');\n  };\n  Parser.prototype.isCurrentLineComment = function () {\n    var ltrimmedLine;\n    ltrimmedLine = Utils.ltrim(this.currentLine, ' ');\n    return ltrimmedLine.charAt(0) === '#';\n  };\n  Parser.prototype.cleanup = function (value) {\n    var count, i, indent, j, l, len, len1, line, lines, ref, ref1, ref2, smallestIndent, trimmedValue;\n    if (value.indexOf(\"\\r\") !== -1) {\n      value = value.split(\"\\r\\n\").join(\"\\n\").split(\"\\r\").join(\"\\n\");\n    }\n    count = 0;\n    ref = this.PATTERN_YAML_HEADER.replaceAll(value, ''), value = ref[0], count = ref[1];\n    this.offset += count;\n    ref1 = this.PATTERN_LEADING_COMMENTS.replaceAll(value, '', 1), trimmedValue = ref1[0], count = ref1[1];\n    if (count === 1) {\n      this.offset += Utils.subStrCount(value, \"\\n\") - Utils.subStrCount(trimmedValue, \"\\n\");\n      value = trimmedValue;\n    }\n    ref2 = this.PATTERN_DOCUMENT_MARKER_START.replaceAll(value, '', 1), trimmedValue = ref2[0], count = ref2[1];\n    if (count === 1) {\n      this.offset += Utils.subStrCount(value, \"\\n\") - Utils.subStrCount(trimmedValue, \"\\n\");\n      value = trimmedValue;\n      value = this.PATTERN_DOCUMENT_MARKER_END.replace(value, '');\n    }\n    lines = value.split(\"\\n\");\n    smallestIndent = -1;\n    for (j = 0, len = lines.length; j < len; j++) {\n      line = lines[j];\n      if (Utils.trim(line, ' ').length === 0) {\n        continue;\n      }\n      indent = line.length - Utils.ltrim(line).length;\n      if (smallestIndent === -1 || indent < smallestIndent) {\n        smallestIndent = indent;\n      }\n    }\n    if (smallestIndent > 0) {\n      for (i = l = 0, len1 = lines.length; l < len1; i = ++l) {\n        line = lines[i];\n        lines[i] = line.slice(smallestIndent);\n      }\n      value = lines.join(\"\\n\");\n    }\n    return value;\n  };\n  Parser.prototype.isNextLineUnIndentedCollection = function (currentIndentation) {\n    var notEOF, ret;\n    if (currentIndentation == null) {\n      currentIndentation = null;\n    }\n    if (currentIndentation == null) {\n      currentIndentation = this.getCurrentLineIndentation();\n    }\n    notEOF = this.moveToNextLine();\n    while (notEOF && this.isCurrentLineEmpty()) {\n      notEOF = this.moveToNextLine();\n    }\n    if (false === notEOF) {\n      return false;\n    }\n    ret = false;\n    if (this.getCurrentLineIndentation() === currentIndentation && this.isStringUnIndentedCollectionItem(this.currentLine)) {\n      ret = true;\n    }\n    this.moveToPreviousLine();\n    return ret;\n  };\n  Parser.prototype.isStringUnIndentedCollectionItem = function () {\n    return this.currentLine === '-' || this.currentLine.slice(0, 2) === '- ';\n  };\n  return Parser;\n}();\nmodule.exports = Parser;","map":{"version":3,"names":["Inline","ParseException","ParseMore","Parser","Pattern","Utils","require","prototype","PATTERN_FOLDED_SCALAR_ALL","PATTERN_FOLDED_SCALAR_END","PATTERN_SEQUENCE_ITEM","PATTERN_ANCHOR_VALUE","PATTERN_COMPACT_NOTATION","REGEX_QUOTED_STRING","PATTERN_MAPPING_ITEM","PATTERN_DECIMAL","PATTERN_INDENT_SPACES","PATTERN_TRAILING_LINES","PATTERN_YAML_HEADER","PATTERN_LEADING_COMMENTS","PATTERN_DOCUMENT_MARKER_START","PATTERN_DOCUMENT_MARKER_END","PATTERN_FOLDED_SCALAR_BY_INDENTATION","CONTEXT_NONE","CONTEXT_SEQUENCE","CONTEXT_MAPPING","offset","lines","currentLineNb","currentLine","refs","parse","value","exceptionOnInvalidType","objectDecoder","alias","allowOverwrite","block","c","context","data","e","first","i","indent","isRef","j","k","key","l","lastKey","len","len1","len2","len3","lineCount","m","matches","mergeNode","n","name","parsed","parsedItem","parser","ref","ref1","ref2","refName","refValue","val","values","cleanup","split","moveToNextLine","isCurrentLineEmpty","getRealCurrentLineNb","exec","trim","ltrim","indexOf","length","isNextLineUnIndentedCollection","push","getNextEmbedBlock","leadspaces","getCurrentLineIndentation","isNextLineIndented","parseValue","configure","parseScalar","error","parsedLine","snippet","slice","Array","String","hasOwnProperty","isEmpty","charAt","indentation","includeUnindentedCollection","isItUnindentedCollection","newIndent","removeComments","removeCommentsPattern","unindentedEmbedBlock","isStringUnIndentedCollectionItem","test","isCurrentLineComment","isCurrentLineBlank","moveToPreviousLine","join","foldedIndent","modifiers","pos","substr","Math","abs","parseInt","isNaN","parseFoldedScalar","separator","replace","type","indicator","line","newText","notEOF","pattern","text","rtrim","ignoreComments","EOF","currentIndentation","ret","trimmedLine","ltrimmedLine","count","smallestIndent","trimmedValue","replaceAll","subStrCount","module","exports"],"sources":["D:/my code/my-app/node_modules/yamljs/lib/Parser.js"],"sourcesContent":["// Generated by CoffeeScript 1.12.4\nvar Inline, ParseException, ParseMore, Parser, Pattern, Utils;\n\nInline = require('./Inline');\n\nPattern = require('./Pattern');\n\nUtils = require('./Utils');\n\nParseException = require('./Exception/ParseException');\n\nParseMore = require('./Exception/ParseMore');\n\nParser = (function() {\n  Parser.prototype.PATTERN_FOLDED_SCALAR_ALL = new Pattern('^(?:(?<type>![^\\\\|>]*)\\\\s+)?(?<separator>\\\\||>)(?<modifiers>\\\\+|\\\\-|\\\\d+|\\\\+\\\\d+|\\\\-\\\\d+|\\\\d+\\\\+|\\\\d+\\\\-)?(?<comments> +#.*)?$');\n\n  Parser.prototype.PATTERN_FOLDED_SCALAR_END = new Pattern('(?<separator>\\\\||>)(?<modifiers>\\\\+|\\\\-|\\\\d+|\\\\+\\\\d+|\\\\-\\\\d+|\\\\d+\\\\+|\\\\d+\\\\-)?(?<comments> +#.*)?$');\n\n  Parser.prototype.PATTERN_SEQUENCE_ITEM = new Pattern('^\\\\-((?<leadspaces>\\\\s+)(?<value>.+?))?\\\\s*$');\n\n  Parser.prototype.PATTERN_ANCHOR_VALUE = new Pattern('^&(?<ref>[^ ]+) *(?<value>.*)');\n\n  Parser.prototype.PATTERN_COMPACT_NOTATION = new Pattern('^(?<key>' + Inline.REGEX_QUOTED_STRING + '|[^ \\'\"\\\\{\\\\[].*?) *\\\\:(\\\\s+(?<value>.+?))?\\\\s*$');\n\n  Parser.prototype.PATTERN_MAPPING_ITEM = new Pattern('^(?<key>' + Inline.REGEX_QUOTED_STRING + '|[^ \\'\"\\\\[\\\\{].*?) *\\\\:(\\\\s+(?<value>.+?))?\\\\s*$');\n\n  Parser.prototype.PATTERN_DECIMAL = new Pattern('\\\\d+');\n\n  Parser.prototype.PATTERN_INDENT_SPACES = new Pattern('^ +');\n\n  Parser.prototype.PATTERN_TRAILING_LINES = new Pattern('(\\n*)$');\n\n  Parser.prototype.PATTERN_YAML_HEADER = new Pattern('^\\\\%YAML[: ][\\\\d\\\\.]+.*\\n', 'm');\n\n  Parser.prototype.PATTERN_LEADING_COMMENTS = new Pattern('^(\\\\#.*?\\n)+', 'm');\n\n  Parser.prototype.PATTERN_DOCUMENT_MARKER_START = new Pattern('^\\\\-\\\\-\\\\-.*?\\n', 'm');\n\n  Parser.prototype.PATTERN_DOCUMENT_MARKER_END = new Pattern('^\\\\.\\\\.\\\\.\\\\s*$', 'm');\n\n  Parser.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION = {};\n\n  Parser.prototype.CONTEXT_NONE = 0;\n\n  Parser.prototype.CONTEXT_SEQUENCE = 1;\n\n  Parser.prototype.CONTEXT_MAPPING = 2;\n\n  function Parser(offset) {\n    this.offset = offset != null ? offset : 0;\n    this.lines = [];\n    this.currentLineNb = -1;\n    this.currentLine = '';\n    this.refs = {};\n  }\n\n  Parser.prototype.parse = function(value, exceptionOnInvalidType, objectDecoder) {\n    var alias, allowOverwrite, block, c, context, data, e, first, i, indent, isRef, j, k, key, l, lastKey, len, len1, len2, len3, lineCount, m, matches, mergeNode, n, name, parsed, parsedItem, parser, ref, ref1, ref2, refName, refValue, val, values;\n    if (exceptionOnInvalidType == null) {\n      exceptionOnInvalidType = false;\n    }\n    if (objectDecoder == null) {\n      objectDecoder = null;\n    }\n    this.currentLineNb = -1;\n    this.currentLine = '';\n    this.lines = this.cleanup(value).split(\"\\n\");\n    data = null;\n    context = this.CONTEXT_NONE;\n    allowOverwrite = false;\n    while (this.moveToNextLine()) {\n      if (this.isCurrentLineEmpty()) {\n        continue;\n      }\n      if (\"\\t\" === this.currentLine[0]) {\n        throw new ParseException('A YAML file cannot contain tabs as indentation.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n      isRef = mergeNode = false;\n      if (values = this.PATTERN_SEQUENCE_ITEM.exec(this.currentLine)) {\n        if (this.CONTEXT_MAPPING === context) {\n          throw new ParseException('You cannot define a sequence item when in a mapping');\n        }\n        context = this.CONTEXT_SEQUENCE;\n        if (data == null) {\n          data = [];\n        }\n        if ((values.value != null) && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {\n          isRef = matches.ref;\n          values.value = matches.value;\n        }\n        if (!(values.value != null) || '' === Utils.trim(values.value, ' ') || Utils.ltrim(values.value, ' ').indexOf('#') === 0) {\n          if (this.currentLineNb < this.lines.length - 1 && !this.isNextLineUnIndentedCollection()) {\n            c = this.getRealCurrentLineNb() + 1;\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            data.push(parser.parse(this.getNextEmbedBlock(null, true), exceptionOnInvalidType, objectDecoder));\n          } else {\n            data.push(null);\n          }\n        } else {\n          if (((ref = values.leadspaces) != null ? ref.length : void 0) && (matches = this.PATTERN_COMPACT_NOTATION.exec(values.value))) {\n            c = this.getRealCurrentLineNb();\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            block = values.value;\n            indent = this.getCurrentLineIndentation();\n            if (this.isNextLineIndented(false)) {\n              block += \"\\n\" + this.getNextEmbedBlock(indent + values.leadspaces.length + 1, true);\n            }\n            data.push(parser.parse(block, exceptionOnInvalidType, objectDecoder));\n          } else {\n            data.push(this.parseValue(values.value, exceptionOnInvalidType, objectDecoder));\n          }\n        }\n      } else if ((values = this.PATTERN_MAPPING_ITEM.exec(this.currentLine)) && values.key.indexOf(' #') === -1) {\n        if (this.CONTEXT_SEQUENCE === context) {\n          throw new ParseException('You cannot define a mapping item when in a sequence');\n        }\n        context = this.CONTEXT_MAPPING;\n        if (data == null) {\n          data = {};\n        }\n        Inline.configure(exceptionOnInvalidType, objectDecoder);\n        try {\n          key = Inline.parseScalar(values.key);\n        } catch (error) {\n          e = error;\n          e.parsedLine = this.getRealCurrentLineNb() + 1;\n          e.snippet = this.currentLine;\n          throw e;\n        }\n        if ('<<' === key) {\n          mergeNode = true;\n          allowOverwrite = true;\n          if (((ref1 = values.value) != null ? ref1.indexOf('*') : void 0) === 0) {\n            refName = values.value.slice(1);\n            if (this.refs[refName] == null) {\n              throw new ParseException('Reference \"' + refName + '\" does not exist.', this.getRealCurrentLineNb() + 1, this.currentLine);\n            }\n            refValue = this.refs[refName];\n            if (typeof refValue !== 'object') {\n              throw new ParseException('YAML merge keys used with a scalar value instead of an object.', this.getRealCurrentLineNb() + 1, this.currentLine);\n            }\n            if (refValue instanceof Array) {\n              for (i = j = 0, len = refValue.length; j < len; i = ++j) {\n                value = refValue[i];\n                if (data[name = String(i)] == null) {\n                  data[name] = value;\n                }\n              }\n            } else {\n              for (key in refValue) {\n                value = refValue[key];\n                if (data[key] == null) {\n                  data[key] = value;\n                }\n              }\n            }\n          } else {\n            if ((values.value != null) && values.value !== '') {\n              value = values.value;\n            } else {\n              value = this.getNextEmbedBlock();\n            }\n            c = this.getRealCurrentLineNb() + 1;\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            parsed = parser.parse(value, exceptionOnInvalidType);\n            if (typeof parsed !== 'object') {\n              throw new ParseException('YAML merge keys used with a scalar value instead of an object.', this.getRealCurrentLineNb() + 1, this.currentLine);\n            }\n            if (parsed instanceof Array) {\n              for (l = 0, len1 = parsed.length; l < len1; l++) {\n                parsedItem = parsed[l];\n                if (typeof parsedItem !== 'object') {\n                  throw new ParseException('Merge items must be objects.', this.getRealCurrentLineNb() + 1, parsedItem);\n                }\n                if (parsedItem instanceof Array) {\n                  for (i = m = 0, len2 = parsedItem.length; m < len2; i = ++m) {\n                    value = parsedItem[i];\n                    k = String(i);\n                    if (!data.hasOwnProperty(k)) {\n                      data[k] = value;\n                    }\n                  }\n                } else {\n                  for (key in parsedItem) {\n                    value = parsedItem[key];\n                    if (!data.hasOwnProperty(key)) {\n                      data[key] = value;\n                    }\n                  }\n                }\n              }\n            } else {\n              for (key in parsed) {\n                value = parsed[key];\n                if (!data.hasOwnProperty(key)) {\n                  data[key] = value;\n                }\n              }\n            }\n          }\n        } else if ((values.value != null) && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {\n          isRef = matches.ref;\n          values.value = matches.value;\n        }\n        if (mergeNode) {\n\n        } else if (!(values.value != null) || '' === Utils.trim(values.value, ' ') || Utils.ltrim(values.value, ' ').indexOf('#') === 0) {\n          if (!(this.isNextLineIndented()) && !(this.isNextLineUnIndentedCollection())) {\n            if (allowOverwrite || data[key] === void 0) {\n              data[key] = null;\n            }\n          } else {\n            c = this.getRealCurrentLineNb() + 1;\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            val = parser.parse(this.getNextEmbedBlock(), exceptionOnInvalidType, objectDecoder);\n            if (allowOverwrite || data[key] === void 0) {\n              data[key] = val;\n            }\n          }\n        } else {\n          val = this.parseValue(values.value, exceptionOnInvalidType, objectDecoder);\n          if (allowOverwrite || data[key] === void 0) {\n            data[key] = val;\n          }\n        }\n      } else {\n        lineCount = this.lines.length;\n        if (1 === lineCount || (2 === lineCount && Utils.isEmpty(this.lines[1]))) {\n          try {\n            value = Inline.parse(this.lines[0], exceptionOnInvalidType, objectDecoder);\n          } catch (error) {\n            e = error;\n            e.parsedLine = this.getRealCurrentLineNb() + 1;\n            e.snippet = this.currentLine;\n            throw e;\n          }\n          if (typeof value === 'object') {\n            if (value instanceof Array) {\n              first = value[0];\n            } else {\n              for (key in value) {\n                first = value[key];\n                break;\n              }\n            }\n            if (typeof first === 'string' && first.indexOf('*') === 0) {\n              data = [];\n              for (n = 0, len3 = value.length; n < len3; n++) {\n                alias = value[n];\n                data.push(this.refs[alias.slice(1)]);\n              }\n              value = data;\n            }\n          }\n          return value;\n        } else if ((ref2 = Utils.ltrim(value).charAt(0)) === '[' || ref2 === '{') {\n          try {\n            return Inline.parse(value, exceptionOnInvalidType, objectDecoder);\n          } catch (error) {\n            e = error;\n            e.parsedLine = this.getRealCurrentLineNb() + 1;\n            e.snippet = this.currentLine;\n            throw e;\n          }\n        }\n        throw new ParseException('Unable to parse.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n      if (isRef) {\n        if (data instanceof Array) {\n          this.refs[isRef] = data[data.length - 1];\n        } else {\n          lastKey = null;\n          for (key in data) {\n            lastKey = key;\n          }\n          this.refs[isRef] = data[lastKey];\n        }\n      }\n    }\n    if (Utils.isEmpty(data)) {\n      return null;\n    } else {\n      return data;\n    }\n  };\n\n  Parser.prototype.getRealCurrentLineNb = function() {\n    return this.currentLineNb + this.offset;\n  };\n\n  Parser.prototype.getCurrentLineIndentation = function() {\n    return this.currentLine.length - Utils.ltrim(this.currentLine, ' ').length;\n  };\n\n  Parser.prototype.getNextEmbedBlock = function(indentation, includeUnindentedCollection) {\n    var data, indent, isItUnindentedCollection, newIndent, removeComments, removeCommentsPattern, unindentedEmbedBlock;\n    if (indentation == null) {\n      indentation = null;\n    }\n    if (includeUnindentedCollection == null) {\n      includeUnindentedCollection = false;\n    }\n    this.moveToNextLine();\n    if (indentation == null) {\n      newIndent = this.getCurrentLineIndentation();\n      unindentedEmbedBlock = this.isStringUnIndentedCollectionItem(this.currentLine);\n      if (!(this.isCurrentLineEmpty()) && 0 === newIndent && !unindentedEmbedBlock) {\n        throw new ParseException('Indentation problem.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n    } else {\n      newIndent = indentation;\n    }\n    data = [this.currentLine.slice(newIndent)];\n    if (!includeUnindentedCollection) {\n      isItUnindentedCollection = this.isStringUnIndentedCollectionItem(this.currentLine);\n    }\n    removeCommentsPattern = this.PATTERN_FOLDED_SCALAR_END;\n    removeComments = !removeCommentsPattern.test(this.currentLine);\n    while (this.moveToNextLine()) {\n      indent = this.getCurrentLineIndentation();\n      if (indent === newIndent) {\n        removeComments = !removeCommentsPattern.test(this.currentLine);\n      }\n      if (removeComments && this.isCurrentLineComment()) {\n        continue;\n      }\n      if (this.isCurrentLineBlank()) {\n        data.push(this.currentLine.slice(newIndent));\n        continue;\n      }\n      if (isItUnindentedCollection && !this.isStringUnIndentedCollectionItem(this.currentLine) && indent === newIndent) {\n        this.moveToPreviousLine();\n        break;\n      }\n      if (indent >= newIndent) {\n        data.push(this.currentLine.slice(newIndent));\n      } else if (Utils.ltrim(this.currentLine).charAt(0) === '#') {\n\n      } else if (0 === indent) {\n        this.moveToPreviousLine();\n        break;\n      } else {\n        throw new ParseException('Indentation problem.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n    }\n    return data.join(\"\\n\");\n  };\n\n  Parser.prototype.moveToNextLine = function() {\n    if (this.currentLineNb >= this.lines.length - 1) {\n      return false;\n    }\n    this.currentLine = this.lines[++this.currentLineNb];\n    return true;\n  };\n\n  Parser.prototype.moveToPreviousLine = function() {\n    this.currentLine = this.lines[--this.currentLineNb];\n  };\n\n  Parser.prototype.parseValue = function(value, exceptionOnInvalidType, objectDecoder) {\n    var e, foldedIndent, matches, modifiers, pos, ref, ref1, val;\n    if (0 === value.indexOf('*')) {\n      pos = value.indexOf('#');\n      if (pos !== -1) {\n        value = value.substr(1, pos - 2);\n      } else {\n        value = value.slice(1);\n      }\n      if (this.refs[value] === void 0) {\n        throw new ParseException('Reference \"' + value + '\" does not exist.', this.currentLine);\n      }\n      return this.refs[value];\n    }\n    if (matches = this.PATTERN_FOLDED_SCALAR_ALL.exec(value)) {\n      modifiers = (ref = matches.modifiers) != null ? ref : '';\n      foldedIndent = Math.abs(parseInt(modifiers));\n      if (isNaN(foldedIndent)) {\n        foldedIndent = 0;\n      }\n      val = this.parseFoldedScalar(matches.separator, this.PATTERN_DECIMAL.replace(modifiers, ''), foldedIndent);\n      if (matches.type != null) {\n        Inline.configure(exceptionOnInvalidType, objectDecoder);\n        return Inline.parseScalar(matches.type + ' ' + val);\n      } else {\n        return val;\n      }\n    }\n    if ((ref1 = value.charAt(0)) === '[' || ref1 === '{' || ref1 === '\"' || ref1 === \"'\") {\n      while (true) {\n        try {\n          return Inline.parse(value, exceptionOnInvalidType, objectDecoder);\n        } catch (error) {\n          e = error;\n          if (e instanceof ParseMore && this.moveToNextLine()) {\n            value += \"\\n\" + Utils.trim(this.currentLine, ' ');\n          } else {\n            e.parsedLine = this.getRealCurrentLineNb() + 1;\n            e.snippet = this.currentLine;\n            throw e;\n          }\n        }\n      }\n    } else {\n      if (this.isNextLineIndented()) {\n        value += \"\\n\" + this.getNextEmbedBlock();\n      }\n      return Inline.parse(value, exceptionOnInvalidType, objectDecoder);\n    }\n  };\n\n  Parser.prototype.parseFoldedScalar = function(separator, indicator, indentation) {\n    var isCurrentLineBlank, j, len, line, matches, newText, notEOF, pattern, ref, text;\n    if (indicator == null) {\n      indicator = '';\n    }\n    if (indentation == null) {\n      indentation = 0;\n    }\n    notEOF = this.moveToNextLine();\n    if (!notEOF) {\n      return '';\n    }\n    isCurrentLineBlank = this.isCurrentLineBlank();\n    text = '';\n    while (notEOF && isCurrentLineBlank) {\n      if (notEOF = this.moveToNextLine()) {\n        text += \"\\n\";\n        isCurrentLineBlank = this.isCurrentLineBlank();\n      }\n    }\n    if (0 === indentation) {\n      if (matches = this.PATTERN_INDENT_SPACES.exec(this.currentLine)) {\n        indentation = matches[0].length;\n      }\n    }\n    if (indentation > 0) {\n      pattern = this.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation];\n      if (pattern == null) {\n        pattern = new Pattern('^ {' + indentation + '}(.*)$');\n        Parser.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation] = pattern;\n      }\n      while (notEOF && (isCurrentLineBlank || (matches = pattern.exec(this.currentLine)))) {\n        if (isCurrentLineBlank) {\n          text += this.currentLine.slice(indentation);\n        } else {\n          text += matches[1];\n        }\n        if (notEOF = this.moveToNextLine()) {\n          text += \"\\n\";\n          isCurrentLineBlank = this.isCurrentLineBlank();\n        }\n      }\n    } else if (notEOF) {\n      text += \"\\n\";\n    }\n    if (notEOF) {\n      this.moveToPreviousLine();\n    }\n    if ('>' === separator) {\n      newText = '';\n      ref = text.split(\"\\n\");\n      for (j = 0, len = ref.length; j < len; j++) {\n        line = ref[j];\n        if (line.length === 0 || line.charAt(0) === ' ') {\n          newText = Utils.rtrim(newText, ' ') + line + \"\\n\";\n        } else {\n          newText += line + ' ';\n        }\n      }\n      text = newText;\n    }\n    if ('+' !== indicator) {\n      text = Utils.rtrim(text);\n    }\n    if ('' === indicator) {\n      text = this.PATTERN_TRAILING_LINES.replace(text, \"\\n\");\n    } else if ('-' === indicator) {\n      text = this.PATTERN_TRAILING_LINES.replace(text, '');\n    }\n    return text;\n  };\n\n  Parser.prototype.isNextLineIndented = function(ignoreComments) {\n    var EOF, currentIndentation, ret;\n    if (ignoreComments == null) {\n      ignoreComments = true;\n    }\n    currentIndentation = this.getCurrentLineIndentation();\n    EOF = !this.moveToNextLine();\n    if (ignoreComments) {\n      while (!EOF && this.isCurrentLineEmpty()) {\n        EOF = !this.moveToNextLine();\n      }\n    } else {\n      while (!EOF && this.isCurrentLineBlank()) {\n        EOF = !this.moveToNextLine();\n      }\n    }\n    if (EOF) {\n      return false;\n    }\n    ret = false;\n    if (this.getCurrentLineIndentation() > currentIndentation) {\n      ret = true;\n    }\n    this.moveToPreviousLine();\n    return ret;\n  };\n\n  Parser.prototype.isCurrentLineEmpty = function() {\n    var trimmedLine;\n    trimmedLine = Utils.trim(this.currentLine, ' ');\n    return trimmedLine.length === 0 || trimmedLine.charAt(0) === '#';\n  };\n\n  Parser.prototype.isCurrentLineBlank = function() {\n    return '' === Utils.trim(this.currentLine, ' ');\n  };\n\n  Parser.prototype.isCurrentLineComment = function() {\n    var ltrimmedLine;\n    ltrimmedLine = Utils.ltrim(this.currentLine, ' ');\n    return ltrimmedLine.charAt(0) === '#';\n  };\n\n  Parser.prototype.cleanup = function(value) {\n    var count, i, indent, j, l, len, len1, line, lines, ref, ref1, ref2, smallestIndent, trimmedValue;\n    if (value.indexOf(\"\\r\") !== -1) {\n      value = value.split(\"\\r\\n\").join(\"\\n\").split(\"\\r\").join(\"\\n\");\n    }\n    count = 0;\n    ref = this.PATTERN_YAML_HEADER.replaceAll(value, ''), value = ref[0], count = ref[1];\n    this.offset += count;\n    ref1 = this.PATTERN_LEADING_COMMENTS.replaceAll(value, '', 1), trimmedValue = ref1[0], count = ref1[1];\n    if (count === 1) {\n      this.offset += Utils.subStrCount(value, \"\\n\") - Utils.subStrCount(trimmedValue, \"\\n\");\n      value = trimmedValue;\n    }\n    ref2 = this.PATTERN_DOCUMENT_MARKER_START.replaceAll(value, '', 1), trimmedValue = ref2[0], count = ref2[1];\n    if (count === 1) {\n      this.offset += Utils.subStrCount(value, \"\\n\") - Utils.subStrCount(trimmedValue, \"\\n\");\n      value = trimmedValue;\n      value = this.PATTERN_DOCUMENT_MARKER_END.replace(value, '');\n    }\n    lines = value.split(\"\\n\");\n    smallestIndent = -1;\n    for (j = 0, len = lines.length; j < len; j++) {\n      line = lines[j];\n      if (Utils.trim(line, ' ').length === 0) {\n        continue;\n      }\n      indent = line.length - Utils.ltrim(line).length;\n      if (smallestIndent === -1 || indent < smallestIndent) {\n        smallestIndent = indent;\n      }\n    }\n    if (smallestIndent > 0) {\n      for (i = l = 0, len1 = lines.length; l < len1; i = ++l) {\n        line = lines[i];\n        lines[i] = line.slice(smallestIndent);\n      }\n      value = lines.join(\"\\n\");\n    }\n    return value;\n  };\n\n  Parser.prototype.isNextLineUnIndentedCollection = function(currentIndentation) {\n    var notEOF, ret;\n    if (currentIndentation == null) {\n      currentIndentation = null;\n    }\n    if (currentIndentation == null) {\n      currentIndentation = this.getCurrentLineIndentation();\n    }\n    notEOF = this.moveToNextLine();\n    while (notEOF && this.isCurrentLineEmpty()) {\n      notEOF = this.moveToNextLine();\n    }\n    if (false === notEOF) {\n      return false;\n    }\n    ret = false;\n    if (this.getCurrentLineIndentation() === currentIndentation && this.isStringUnIndentedCollectionItem(this.currentLine)) {\n      ret = true;\n    }\n    this.moveToPreviousLine();\n    return ret;\n  };\n\n  Parser.prototype.isStringUnIndentedCollectionItem = function() {\n    return this.currentLine === '-' || this.currentLine.slice(0, 2) === '- ';\n  };\n\n  return Parser;\n\n})();\n\nmodule.exports = Parser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}