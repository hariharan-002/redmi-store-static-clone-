{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { isCEPolyfill } from './dom.js';\nimport { isTemplatePartActive } from './template.js';\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nexport class TemplateInstance {\n  constructor(template, processor, options) {\n    this.__parts = [];\n    this.template = template;\n    this.processor = processor;\n    this.options = options;\n  }\n  update(values) {\n    let i = 0;\n    for (const part of this.__parts) {\n      if (part !== undefined) {\n        part.setValue(values[i]);\n      }\n      i++;\n    }\n    for (const part of this.__parts) {\n      if (part !== undefined) {\n        part.commit();\n      }\n    }\n  }\n  _clone() {\n    // There are a number of steps in the lifecycle of a template instance's\n    // DOM fragment:\n    //  1. Clone - create the instance fragment\n    //  2. Adopt - adopt into the main document\n    //  3. Process - find part markers and create parts\n    //  4. Upgrade - upgrade custom elements\n    //  5. Update - set node, attribute, property, etc., values\n    //  6. Connect - connect to the document. Optional and outside of this\n    //     method.\n    //\n    // We have a few constraints on the ordering of these steps:\n    //  * We need to upgrade before updating, so that property values will pass\n    //    through any property setters.\n    //  * We would like to process before upgrading so that we're sure that the\n    //    cloned fragment is inert and not disturbed by self-modifying DOM.\n    //  * We want custom elements to upgrade even in disconnected fragments.\n    //\n    // Given these constraints, with full custom elements support we would\n    // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect\n    //\n    // But Safari does not implement CustomElementRegistry#upgrade, so we\n    // can not implement that order and still have upgrade-before-update and\n    // upgrade disconnected fragments. So we instead sacrifice the\n    // process-before-upgrade constraint, since in Custom Elements v1 elements\n    // must not modify their light DOM in the constructor. We still have issues\n    // when co-existing with CEv0 elements like Polymer 1, and with polyfills\n    // that don't strictly adhere to the no-modification rule because shadow\n    // DOM, which may be created in the constructor, is emulated by being placed\n    // in the light DOM.\n    //\n    // The resulting order is on native is: Clone, Adopt, Upgrade, Process,\n    // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade\n    // in one step.\n    //\n    // The Custom Elements v1 polyfill supports upgrade(), so the order when\n    // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,\n    // Connect.\n    const fragment = isCEPolyfill ? this.template.element.content.cloneNode(true) : document.importNode(this.template.element.content, true);\n    const stack = [];\n    const parts = this.template.parts;\n    // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n    const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);\n    let partIndex = 0;\n    let nodeIndex = 0;\n    let part;\n    let node = walker.nextNode();\n    // Loop through all the nodes and parts of a template\n    while (partIndex < parts.length) {\n      part = parts[partIndex];\n      if (!isTemplatePartActive(part)) {\n        this.__parts.push(undefined);\n        partIndex++;\n        continue;\n      }\n      // Progress the tree walker until we find our next part's node.\n      // Note that multiple parts may share the same node (attribute parts\n      // on a single element), so this loop may not run at all.\n      while (nodeIndex < part.index) {\n        nodeIndex++;\n        if (node.nodeName === 'TEMPLATE') {\n          stack.push(node);\n          walker.currentNode = node.content;\n        }\n        if ((node = walker.nextNode()) === null) {\n          // We've exhausted the content inside a nested template element.\n          // Because we still have parts (the outer for-loop), we know:\n          // - There is a template in the stack\n          // - The walker will find a nextNode outside the template\n          walker.currentNode = stack.pop();\n          node = walker.nextNode();\n        }\n      }\n      // We've arrived at our part's node.\n      if (part.type === 'node') {\n        const part = this.processor.handleTextExpression(this.options);\n        part.insertAfterNode(node.previousSibling);\n        this.__parts.push(part);\n      } else {\n        this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));\n      }\n      partIndex++;\n    }\n    if (isCEPolyfill) {\n      document.adoptNode(fragment);\n      customElements.upgrade(fragment);\n    }\n    return fragment;\n  }\n}","map":{"version":3,"names":["isCEPolyfill","isTemplatePartActive","TemplateInstance","constructor","template","processor","options","__parts","update","values","i","part","undefined","setValue","commit","_clone","fragment","element","content","cloneNode","document","importNode","stack","parts","walker","createTreeWalker","partIndex","nodeIndex","node","nextNode","length","push","index","nodeName","currentNode","pop","type","handleTextExpression","insertAfterNode","previousSibling","handleAttributeExpressions","name","strings","adoptNode","customElements","upgrade"],"sources":["D:\\my code\\my-app\\node_modules\\lit-html\\src\\lib\\template-instance.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {isCEPolyfill} from './dom.js';\nimport {Part} from './part.js';\nimport {RenderOptions} from './render-options.js';\nimport {TemplateProcessor} from './template-processor.js';\nimport {isTemplatePartActive, Template, TemplatePart} from './template.js';\n\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nexport class TemplateInstance {\n  private readonly __parts: Array<Part|undefined> = [];\n  readonly processor: TemplateProcessor;\n  readonly options: RenderOptions;\n  readonly template: Template;\n\n  constructor(\n      template: Template, processor: TemplateProcessor,\n      options: RenderOptions) {\n    this.template = template;\n    this.processor = processor;\n    this.options = options;\n  }\n\n  update(values: readonly unknown[]) {\n    let i = 0;\n    for (const part of this.__parts) {\n      if (part !== undefined) {\n        part.setValue(values[i]);\n      }\n      i++;\n    }\n    for (const part of this.__parts) {\n      if (part !== undefined) {\n        part.commit();\n      }\n    }\n  }\n\n  _clone(): DocumentFragment {\n    // There are a number of steps in the lifecycle of a template instance's\n    // DOM fragment:\n    //  1. Clone - create the instance fragment\n    //  2. Adopt - adopt into the main document\n    //  3. Process - find part markers and create parts\n    //  4. Upgrade - upgrade custom elements\n    //  5. Update - set node, attribute, property, etc., values\n    //  6. Connect - connect to the document. Optional and outside of this\n    //     method.\n    //\n    // We have a few constraints on the ordering of these steps:\n    //  * We need to upgrade before updating, so that property values will pass\n    //    through any property setters.\n    //  * We would like to process before upgrading so that we're sure that the\n    //    cloned fragment is inert and not disturbed by self-modifying DOM.\n    //  * We want custom elements to upgrade even in disconnected fragments.\n    //\n    // Given these constraints, with full custom elements support we would\n    // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect\n    //\n    // But Safari does not implement CustomElementRegistry#upgrade, so we\n    // can not implement that order and still have upgrade-before-update and\n    // upgrade disconnected fragments. So we instead sacrifice the\n    // process-before-upgrade constraint, since in Custom Elements v1 elements\n    // must not modify their light DOM in the constructor. We still have issues\n    // when co-existing with CEv0 elements like Polymer 1, and with polyfills\n    // that don't strictly adhere to the no-modification rule because shadow\n    // DOM, which may be created in the constructor, is emulated by being placed\n    // in the light DOM.\n    //\n    // The resulting order is on native is: Clone, Adopt, Upgrade, Process,\n    // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade\n    // in one step.\n    //\n    // The Custom Elements v1 polyfill supports upgrade(), so the order when\n    // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,\n    // Connect.\n\n    const fragment = isCEPolyfill ?\n        this.template.element.content.cloneNode(true) as DocumentFragment :\n        document.importNode(this.template.element.content, true);\n\n    const stack: Node[] = [];\n    const parts = this.template.parts;\n    // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n    const walker = document.createTreeWalker(\n        fragment,\n        133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,\n        null,\n        false);\n    let partIndex = 0;\n    let nodeIndex = 0;\n    let part: TemplatePart;\n    let node = walker.nextNode();\n    // Loop through all the nodes and parts of a template\n    while (partIndex < parts.length) {\n      part = parts[partIndex];\n      if (!isTemplatePartActive(part)) {\n        this.__parts.push(undefined);\n        partIndex++;\n        continue;\n      }\n\n      // Progress the tree walker until we find our next part's node.\n      // Note that multiple parts may share the same node (attribute parts\n      // on a single element), so this loop may not run at all.\n      while (nodeIndex < part.index) {\n        nodeIndex++;\n        if (node!.nodeName === 'TEMPLATE') {\n          stack.push(node!);\n          walker.currentNode = (node as HTMLTemplateElement).content;\n        }\n        if ((node = walker.nextNode()) === null) {\n          // We've exhausted the content inside a nested template element.\n          // Because we still have parts (the outer for-loop), we know:\n          // - There is a template in the stack\n          // - The walker will find a nextNode outside the template\n          walker.currentNode = stack.pop()!;\n          node = walker.nextNode();\n        }\n      }\n\n      // We've arrived at our part's node.\n      if (part.type === 'node') {\n        const part = this.processor.handleTextExpression(this.options);\n        part.insertAfterNode(node!.previousSibling!);\n        this.__parts.push(part);\n      } else {\n        this.__parts.push(...this.processor.handleAttributeExpressions(\n            node as Element, part.name, part.strings, this.options));\n      }\n      partIndex++;\n    }\n\n    if (isCEPolyfill) {\n      document.adoptNode(fragment);\n      customElements.upgrade(fragment);\n    }\n    return fragment;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}