{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { isTemplatePartActive } from './template.js';\nconst walkerNodeFilter = 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */;\n/**\n * Removes the list of nodes from a Template safely. In addition to removing\n * nodes from the Template, the Template part indices are updated to match\n * the mutated Template DOM.\n *\n * As the template is walked the removal state is tracked and\n * part indices are adjusted as needed.\n *\n * div\n *   div#1 (remove) <-- start removing (removing node is div#1)\n *     div\n *       div#2 (remove)  <-- continue removing (removing node is still div#1)\n *         div\n * div <-- stop removing since previous sibling is the removing node (div#1,\n * removed 4 nodes)\n */\nexport function removeNodesFromTemplate(template, nodesToRemove) {\n  const {\n    element: {\n      content\n    },\n    parts\n  } = template;\n  const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);\n  let partIndex = nextActiveIndexInTemplateParts(parts);\n  let part = parts[partIndex];\n  let nodeIndex = -1;\n  let removeCount = 0;\n  const nodesToRemoveInTemplate = [];\n  let currentRemovingNode = null;\n  while (walker.nextNode()) {\n    nodeIndex++;\n    const node = walker.currentNode;\n    // End removal if stepped past the removing node\n    if (node.previousSibling === currentRemovingNode) {\n      currentRemovingNode = null;\n    }\n    // A node to remove was found in the template\n    if (nodesToRemove.has(node)) {\n      nodesToRemoveInTemplate.push(node);\n      // Track node we're removing\n      if (currentRemovingNode === null) {\n        currentRemovingNode = node;\n      }\n    }\n    // When removing, increment count by which to adjust subsequent part indices\n    if (currentRemovingNode !== null) {\n      removeCount++;\n    }\n    while (part !== undefined && part.index === nodeIndex) {\n      // If part is in a removed node deactivate it by setting index to -1 or\n      // adjust the index as needed.\n      part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;\n      // go to the next active part.\n      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n      part = parts[partIndex];\n    }\n  }\n  nodesToRemoveInTemplate.forEach(n => n.parentNode.removeChild(n));\n}\nconst countNodes = node => {\n  let count = node.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */ ? 0 : 1;\n  const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);\n  while (walker.nextNode()) {\n    count++;\n  }\n  return count;\n};\nconst nextActiveIndexInTemplateParts = (parts, startIndex = -1) => {\n  for (let i = startIndex + 1; i < parts.length; i++) {\n    const part = parts[i];\n    if (isTemplatePartActive(part)) {\n      return i;\n    }\n  }\n  return -1;\n};\n/**\n * Inserts the given node into the Template, optionally before the given\n * refNode. In addition to inserting the node into the Template, the Template\n * part indices are updated to match the mutated Template DOM.\n */\nexport function insertNodeIntoTemplate(template, node, refNode = null) {\n  const {\n    element: {\n      content\n    },\n    parts\n  } = template;\n  // If there's no refNode, then put node at end of template.\n  // No part indices need to be shifted in this case.\n  if (refNode === null || refNode === undefined) {\n    content.appendChild(node);\n    return;\n  }\n  const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);\n  let partIndex = nextActiveIndexInTemplateParts(parts);\n  let insertCount = 0;\n  let walkerIndex = -1;\n  while (walker.nextNode()) {\n    walkerIndex++;\n    const walkerNode = walker.currentNode;\n    if (walkerNode === refNode) {\n      insertCount = countNodes(node);\n      refNode.parentNode.insertBefore(node, refNode);\n    }\n    while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {\n      // If we've inserted the node, simply adjust all subsequent parts\n      if (insertCount > 0) {\n        while (partIndex !== -1) {\n          parts[partIndex].index += insertCount;\n          partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n        }\n        return;\n      }\n      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n    }\n  }\n}","map":{"version":3,"names":["isTemplatePartActive","walkerNodeFilter","removeNodesFromTemplate","template","nodesToRemove","element","content","parts","walker","document","createTreeWalker","partIndex","nextActiveIndexInTemplateParts","part","nodeIndex","removeCount","nodesToRemoveInTemplate","currentRemovingNode","nextNode","node","currentNode","previousSibling","has","push","undefined","index","forEach","n","parentNode","removeChild","countNodes","count","nodeType","startIndex","i","length","insertNodeIntoTemplate","refNode","appendChild","insertCount","walkerIndex","walkerNode","insertBefore"],"sources":["D:\\my code\\my-app\\node_modules\\lit-html\\src\\lib\\modify-template.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {isTemplatePartActive, Template, TemplatePart} from './template.js';\n\nconst walkerNodeFilter = 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */;\n\n/**\n * Removes the list of nodes from a Template safely. In addition to removing\n * nodes from the Template, the Template part indices are updated to match\n * the mutated Template DOM.\n *\n * As the template is walked the removal state is tracked and\n * part indices are adjusted as needed.\n *\n * div\n *   div#1 (remove) <-- start removing (removing node is div#1)\n *     div\n *       div#2 (remove)  <-- continue removing (removing node is still div#1)\n *         div\n * div <-- stop removing since previous sibling is the removing node (div#1,\n * removed 4 nodes)\n */\nexport function removeNodesFromTemplate(\n    template: Template, nodesToRemove: Set<Node>) {\n  const {element: {content}, parts} = template;\n  const walker =\n      document.createTreeWalker(content, walkerNodeFilter, null, false);\n  let partIndex = nextActiveIndexInTemplateParts(parts);\n  let part = parts[partIndex];\n  let nodeIndex = -1;\n  let removeCount = 0;\n  const nodesToRemoveInTemplate = [];\n  let currentRemovingNode: Node|null = null;\n  while (walker.nextNode()) {\n    nodeIndex++;\n    const node = walker.currentNode as Element;\n    // End removal if stepped past the removing node\n    if (node.previousSibling === currentRemovingNode) {\n      currentRemovingNode = null;\n    }\n    // A node to remove was found in the template\n    if (nodesToRemove.has(node)) {\n      nodesToRemoveInTemplate.push(node);\n      // Track node we're removing\n      if (currentRemovingNode === null) {\n        currentRemovingNode = node;\n      }\n    }\n    // When removing, increment count by which to adjust subsequent part indices\n    if (currentRemovingNode !== null) {\n      removeCount++;\n    }\n    while (part !== undefined && part.index === nodeIndex) {\n      // If part is in a removed node deactivate it by setting index to -1 or\n      // adjust the index as needed.\n      part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;\n      // go to the next active part.\n      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n      part = parts[partIndex];\n    }\n  }\n  nodesToRemoveInTemplate.forEach((n) => n.parentNode!.removeChild(n));\n}\n\nconst countNodes = (node: Node) => {\n  let count = (node.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */) ? 0 : 1;\n  const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);\n  while (walker.nextNode()) {\n    count++;\n  }\n  return count;\n};\n\nconst nextActiveIndexInTemplateParts =\n    (parts: TemplatePart[], startIndex = -1) => {\n      for (let i = startIndex + 1; i < parts.length; i++) {\n        const part = parts[i];\n        if (isTemplatePartActive(part)) {\n          return i;\n        }\n      }\n      return -1;\n    };\n\n/**\n * Inserts the given node into the Template, optionally before the given\n * refNode. In addition to inserting the node into the Template, the Template\n * part indices are updated to match the mutated Template DOM.\n */\nexport function insertNodeIntoTemplate(\n    template: Template, node: Node, refNode: Node|null = null) {\n  const {element: {content}, parts} = template;\n  // If there's no refNode, then put node at end of template.\n  // No part indices need to be shifted in this case.\n  if (refNode === null || refNode === undefined) {\n    content.appendChild(node);\n    return;\n  }\n  const walker =\n      document.createTreeWalker(content, walkerNodeFilter, null, false);\n  let partIndex = nextActiveIndexInTemplateParts(parts);\n  let insertCount = 0;\n  let walkerIndex = -1;\n  while (walker.nextNode()) {\n    walkerIndex++;\n    const walkerNode = walker.currentNode as Element;\n    if (walkerNode === refNode) {\n      insertCount = countNodes(node);\n      refNode.parentNode!.insertBefore(node, refNode);\n    }\n    while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {\n      // If we've inserted the node, simply adjust all subsequent parts\n      if (insertCount > 0) {\n        while (partIndex !== -1) {\n          parts[partIndex].index += insertCount;\n          partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n        }\n        return;\n      }\n      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}