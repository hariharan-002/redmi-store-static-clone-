{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * Module to add shady DOM/shady CSS polyfill support to lit-html template\n * rendering. See the [[render]] method for details.\n *\n * @packageDocumentation\n */\n/**\n * Do not remove this comment; it keeps typedoc from misplacing the module\n * docs.\n */\nimport { removeNodes } from './dom.js';\nimport { insertNodeIntoTemplate, removeNodesFromTemplate } from './modify-template.js';\nimport { parts, render as litRender } from './render.js';\nimport { templateCaches } from './template-factory.js';\nimport { TemplateInstance } from './template-instance.js';\nimport { marker, Template } from './template.js';\nexport { html, svg, TemplateResult } from '../lit-html.js';\n// Get a key to lookup in `templateCaches`.\nconst getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;\nlet compatibleShadyCSSVersion = true;\nif (typeof window.ShadyCSS === 'undefined') {\n  compatibleShadyCSSVersion = false;\n} else if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {\n  console.warn(`Incompatible ShadyCSS version detected. ` + `Please update to at least @webcomponents/webcomponentsjs@2.0.2 and ` + `@webcomponents/shadycss@1.3.1.`);\n  compatibleShadyCSSVersion = false;\n}\n/**\n * Template factory which scopes template DOM using ShadyCSS.\n * @param scopeName {string}\n */\nexport const shadyTemplateFactory = scopeName => result => {\n  const cacheKey = getTemplateCacheKey(result.type, scopeName);\n  let templateCache = templateCaches.get(cacheKey);\n  if (templateCache === undefined) {\n    templateCache = {\n      stringsArray: new WeakMap(),\n      keyString: new Map()\n    };\n    templateCaches.set(cacheKey, templateCache);\n  }\n  let template = templateCache.stringsArray.get(result.strings);\n  if (template !== undefined) {\n    return template;\n  }\n  const key = result.strings.join(marker);\n  template = templateCache.keyString.get(key);\n  if (template === undefined) {\n    const element = result.getTemplateElement();\n    if (compatibleShadyCSSVersion) {\n      window.ShadyCSS.prepareTemplateDom(element, scopeName);\n    }\n    template = new Template(result, element);\n    templateCache.keyString.set(key, template);\n  }\n  templateCache.stringsArray.set(result.strings, template);\n  return template;\n};\nconst TEMPLATE_TYPES = ['html', 'svg'];\n/**\n * Removes all style elements from Templates for the given scopeName.\n */\nconst removeStylesFromLitTemplates = scopeName => {\n  TEMPLATE_TYPES.forEach(type => {\n    const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));\n    if (templates !== undefined) {\n      templates.keyString.forEach(template => {\n        const {\n          element: {\n            content\n          }\n        } = template;\n        // IE 11 doesn't support the iterable param Set constructor\n        const styles = new Set();\n        Array.from(content.querySelectorAll('style')).forEach(s => {\n          styles.add(s);\n        });\n        removeNodesFromTemplate(template, styles);\n      });\n    }\n  });\n};\nconst shadyRenderSet = new Set();\n/**\n * For the given scope name, ensures that ShadyCSS style scoping is performed.\n * This is done just once per scope name so the fragment and template cannot\n * be modified.\n * (1) extracts styles from the rendered fragment and hands them to ShadyCSS\n * to be scoped and appended to the document\n * (2) removes style elements from all lit-html Templates for this scope name.\n *\n * Note, <style> elements can only be placed into templates for the\n * initial rendering of the scope. If <style> elements are included in templates\n * dynamically rendered to the scope (after the first scope render), they will\n * not be scoped and the <style> will be left in the template and rendered\n * output.\n */\nconst prepareTemplateStyles = (scopeName, renderedDOM, template) => {\n  shadyRenderSet.add(scopeName);\n  // If `renderedDOM` is stamped from a Template, then we need to edit that\n  // Template's underlying template element. Otherwise, we create one here\n  // to give to ShadyCSS, which still requires one while scoping.\n  const templateElement = !!template ? template.element : document.createElement('template');\n  // Move styles out of rendered DOM and store.\n  const styles = renderedDOM.querySelectorAll('style');\n  const {\n    length\n  } = styles;\n  // If there are no styles, skip unnecessary work\n  if (length === 0) {\n    // Ensure prepareTemplateStyles is called to support adding\n    // styles via `prepareAdoptedCssText` since that requires that\n    // `prepareTemplateStyles` is called.\n    //\n    // ShadyCSS will only update styles containing @apply in the template\n    // given to `prepareTemplateStyles`. If no lit Template was given,\n    // ShadyCSS will not be able to update uses of @apply in any relevant\n    // template. However, this is not a problem because we only create the\n    // template for the purpose of supporting `prepareAdoptedCssText`,\n    // which doesn't support @apply at all.\n    window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);\n    return;\n  }\n  const condensedStyle = document.createElement('style');\n  // Collect styles into a single style. This helps us make sure ShadyCSS\n  // manipulations will not prevent us from being able to fix up template\n  // part indices.\n  // NOTE: collecting styles is inefficient for browsers but ShadyCSS\n  // currently does this anyway. When it does not, this should be changed.\n  for (let i = 0; i < length; i++) {\n    const style = styles[i];\n    style.parentNode.removeChild(style);\n    condensedStyle.textContent += style.textContent;\n  }\n  // Remove styles from nested templates in this scope.\n  removeStylesFromLitTemplates(scopeName);\n  // And then put the condensed style into the \"root\" template passed in as\n  // `template`.\n  const content = templateElement.content;\n  if (!!template) {\n    insertNodeIntoTemplate(template, condensedStyle, content.firstChild);\n  } else {\n    content.insertBefore(condensedStyle, content.firstChild);\n  }\n  // Note, it's important that ShadyCSS gets the template that `lit-html`\n  // will actually render so that it can update the style inside when\n  // needed (e.g. @apply native Shadow DOM case).\n  window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);\n  const style = content.querySelector('style');\n  if (window.ShadyCSS.nativeShadow && style !== null) {\n    // When in native Shadow DOM, ensure the style created by ShadyCSS is\n    // included in initially rendered output (`renderedDOM`).\n    renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);\n  } else if (!!template) {\n    // When no style is left in the template, parts will be broken as a\n    // result. To fix this, we put back the style node ShadyCSS removed\n    // and then tell lit to remove that node from the template.\n    // There can be no style in the template in 2 cases (1) when Shady DOM\n    // is in use, ShadyCSS removes all styles, (2) when native Shadow DOM\n    // is in use ShadyCSS removes the style if it contains no content.\n    // NOTE, ShadyCSS creates its own style so we can safely add/remove\n    // `condensedStyle` here.\n    content.insertBefore(condensedStyle, content.firstChild);\n    const removes = new Set();\n    removes.add(condensedStyle);\n    removeNodesFromTemplate(template, removes);\n  }\n};\n/**\n * Extension to the standard `render` method which supports rendering\n * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)\n * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used\n * or when the webcomponentsjs\n * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.\n *\n * Adds a `scopeName` option which is used to scope element DOM and stylesheets\n * when native ShadowDOM is unavailable. The `scopeName` will be added to\n * the class attribute of all rendered DOM. In addition, any style elements will\n * be automatically re-written with this `scopeName` selector and moved out\n * of the rendered DOM and into the document `<head>`.\n *\n * It is common to use this render method in conjunction with a custom element\n * which renders a shadowRoot. When this is done, typically the element's\n * `localName` should be used as the `scopeName`.\n *\n * In addition to DOM scoping, ShadyCSS also supports a basic shim for css\n * custom properties (needed only on older browsers like IE11) and a shim for\n * a deprecated feature called `@apply` that supports applying a set of css\n * custom properties to a given location.\n *\n * Usage considerations:\n *\n * * Part values in `<style>` elements are only applied the first time a given\n * `scopeName` renders. Subsequent changes to parts in style elements will have\n * no effect. Because of this, parts in style elements should only be used for\n * values that will never change, for example parts that set scope-wide theme\n * values or parts which render shared style elements.\n *\n * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a\n * custom element's `constructor` is not supported. Instead rendering should\n * either done asynchronously, for example at microtask timing (for example\n * `Promise.resolve()`), or be deferred until the first time the element's\n * `connectedCallback` runs.\n *\n * Usage considerations when using shimmed custom properties or `@apply`:\n *\n * * Whenever any dynamic changes are made which affect\n * css custom properties, `ShadyCSS.styleElement(element)` must be called\n * to update the element. There are two cases when this is needed:\n * (1) the element is connected to a new parent, (2) a class is added to the\n * element that causes it to match different custom properties.\n * To address the first case when rendering a custom element, `styleElement`\n * should be called in the element's `connectedCallback`.\n *\n * * Shimmed custom properties may only be defined either for an entire\n * shadowRoot (for example, in a `:host` rule) or via a rule that directly\n * matches an element with a shadowRoot. In other words, instead of flowing from\n * parent to child as do native css custom properties, shimmed custom properties\n * flow only from shadowRoots to nested shadowRoots.\n *\n * * When using `@apply` mixing css shorthand property names with\n * non-shorthand names (for example `border` and `border-width`) is not\n * supported.\n */\nexport const render = (result, container, options) => {\n  if (!options || typeof options !== 'object' || !options.scopeName) {\n    throw new Error('The `scopeName` option is required.');\n  }\n  const scopeName = options.scopeName;\n  const hasRendered = parts.has(container);\n  const needsScoping = compatibleShadyCSSVersion && container.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */ && !!container.host;\n  // Handle first render to a scope specially...\n  const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);\n  // On first scope render, render into a fragment; this cannot be a single\n  // fragment that is reused since nested renders can occur synchronously.\n  const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;\n  litRender(result, renderContainer, Object.assign({\n    templateFactory: shadyTemplateFactory(scopeName)\n  }, options));\n  // When performing first scope render,\n  // (1) We've rendered into a fragment so that there's a chance to\n  // `prepareTemplateStyles` before sub-elements hit the DOM\n  // (which might cause them to render based on a common pattern of\n  // rendering in a custom element's `connectedCallback`);\n  // (2) Scope the template with ShadyCSS one time only for this scope.\n  // (3) Render the fragment into the container and make sure the\n  // container knows its `part` is the one we just rendered. This ensures\n  // DOM will be re-used on subsequent renders.\n  if (firstScopeRender) {\n    const part = parts.get(renderContainer);\n    parts.delete(renderContainer);\n    // ShadyCSS might have style sheets (e.g. from `prepareAdoptedCssText`)\n    // that should apply to `renderContainer` even if the rendered value is\n    // not a TemplateInstance. However, it will only insert scoped styles\n    // into the document if `prepareTemplateStyles` has already been called\n    // for the given scope name.\n    const template = part.value instanceof TemplateInstance ? part.value.template : undefined;\n    prepareTemplateStyles(scopeName, renderContainer, template);\n    removeNodes(container, container.firstChild);\n    container.appendChild(renderContainer);\n    parts.set(container, part);\n  }\n  // After elements have hit the DOM, update styling if this is the\n  // initial render to this container.\n  // This is needed whenever dynamic changes are made so it would be\n  // safest to do every render; however, this would regress performance\n  // so we leave it up to the user to call `ShadyCSS.styleElement`\n  // for dynamic changes.\n  if (!hasRendered && needsScoping) {\n    window.ShadyCSS.styleElement(container.host);\n  }\n};","map":{"version":3,"names":["removeNodes","insertNodeIntoTemplate","removeNodesFromTemplate","parts","render","litRender","templateCaches","TemplateInstance","marker","Template","html","svg","TemplateResult","getTemplateCacheKey","type","scopeName","compatibleShadyCSSVersion","window","ShadyCSS","prepareTemplateDom","console","warn","shadyTemplateFactory","result","cacheKey","templateCache","get","undefined","stringsArray","WeakMap","keyString","Map","set","template","strings","key","join","element","getTemplateElement","TEMPLATE_TYPES","removeStylesFromLitTemplates","forEach","templates","content","styles","Set","Array","from","querySelectorAll","s","add","shadyRenderSet","prepareTemplateStyles","renderedDOM","templateElement","document","createElement","length","condensedStyle","i","style","parentNode","removeChild","textContent","firstChild","insertBefore","querySelector","nativeShadow","cloneNode","removes","container","options","Error","hasRendered","has","needsScoping","nodeType","host","firstScopeRender","renderContainer","createDocumentFragment","Object","assign","templateFactory","part","delete","value","appendChild","styleElement"],"sources":["D:\\my code\\my-app\\node_modules\\lit-html\\src\\lib\\shady-render.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * Module to add shady DOM/shady CSS polyfill support to lit-html template\n * rendering. See the [[render]] method for details.\n *\n * @packageDocumentation\n */\n\n/**\n * Do not remove this comment; it keeps typedoc from misplacing the module\n * docs.\n */\nimport {removeNodes} from './dom.js';\nimport {insertNodeIntoTemplate, removeNodesFromTemplate} from './modify-template.js';\nimport {RenderOptions} from './render-options.js';\nimport {parts, render as litRender} from './render.js';\nimport {templateCaches} from './template-factory.js';\nimport {TemplateInstance} from './template-instance.js';\nimport {TemplateResult} from './template-result.js';\nimport {marker, Template} from './template.js';\n\nexport {html, svg, TemplateResult} from '../lit-html.js';\n\n// Get a key to lookup in `templateCaches`.\nconst getTemplateCacheKey = (type: string, scopeName: string) =>\n    `${type}--${scopeName}`;\n\nlet compatibleShadyCSSVersion = true;\n\nif (typeof window.ShadyCSS === 'undefined') {\n  compatibleShadyCSSVersion = false;\n} else if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {\n  console.warn(\n      `Incompatible ShadyCSS version detected. ` +\n      `Please update to at least @webcomponents/webcomponentsjs@2.0.2 and ` +\n      `@webcomponents/shadycss@1.3.1.`);\n  compatibleShadyCSSVersion = false;\n}\n\n/**\n * Template factory which scopes template DOM using ShadyCSS.\n * @param scopeName {string}\n */\nexport const shadyTemplateFactory = (scopeName: string) =>\n    (result: TemplateResult) => {\n      const cacheKey = getTemplateCacheKey(result.type, scopeName);\n      let templateCache = templateCaches.get(cacheKey);\n      if (templateCache === undefined) {\n        templateCache = {\n          stringsArray: new WeakMap<TemplateStringsArray, Template>(),\n          keyString: new Map<string, Template>()\n        };\n        templateCaches.set(cacheKey, templateCache);\n      }\n\n      let template = templateCache.stringsArray.get(result.strings);\n      if (template !== undefined) {\n        return template;\n      }\n\n      const key = result.strings.join(marker);\n      template = templateCache.keyString.get(key);\n      if (template === undefined) {\n        const element = result.getTemplateElement();\n        if (compatibleShadyCSSVersion) {\n          window.ShadyCSS!.prepareTemplateDom(element, scopeName);\n        }\n        template = new Template(result, element);\n        templateCache.keyString.set(key, template);\n      }\n      templateCache.stringsArray.set(result.strings, template);\n      return template;\n    };\n\nconst TEMPLATE_TYPES = ['html', 'svg'];\n\n/**\n * Removes all style elements from Templates for the given scopeName.\n */\nconst removeStylesFromLitTemplates = (scopeName: string) => {\n  TEMPLATE_TYPES.forEach((type) => {\n    const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));\n    if (templates !== undefined) {\n      templates.keyString.forEach((template) => {\n        const {element: {content}} = template;\n        // IE 11 doesn't support the iterable param Set constructor\n        const styles = new Set<Element>();\n        Array.from(content.querySelectorAll('style')).forEach((s: Element) => {\n          styles.add(s);\n        });\n        removeNodesFromTemplate(template, styles);\n      });\n    }\n  });\n};\n\nconst shadyRenderSet = new Set<string>();\n\n/**\n * For the given scope name, ensures that ShadyCSS style scoping is performed.\n * This is done just once per scope name so the fragment and template cannot\n * be modified.\n * (1) extracts styles from the rendered fragment and hands them to ShadyCSS\n * to be scoped and appended to the document\n * (2) removes style elements from all lit-html Templates for this scope name.\n *\n * Note, <style> elements can only be placed into templates for the\n * initial rendering of the scope. If <style> elements are included in templates\n * dynamically rendered to the scope (after the first scope render), they will\n * not be scoped and the <style> will be left in the template and rendered\n * output.\n */\nconst prepareTemplateStyles =\n    (scopeName: string, renderedDOM: DocumentFragment, template?: Template) => {\n      shadyRenderSet.add(scopeName);\n      // If `renderedDOM` is stamped from a Template, then we need to edit that\n      // Template's underlying template element. Otherwise, we create one here\n      // to give to ShadyCSS, which still requires one while scoping.\n      const templateElement =\n          !!template ? template.element : document.createElement('template');\n      // Move styles out of rendered DOM and store.\n      const styles = renderedDOM.querySelectorAll('style');\n      const {length} = styles;\n      // If there are no styles, skip unnecessary work\n      if (length === 0) {\n        // Ensure prepareTemplateStyles is called to support adding\n        // styles via `prepareAdoptedCssText` since that requires that\n        // `prepareTemplateStyles` is called.\n        //\n        // ShadyCSS will only update styles containing @apply in the template\n        // given to `prepareTemplateStyles`. If no lit Template was given,\n        // ShadyCSS will not be able to update uses of @apply in any relevant\n        // template. However, this is not a problem because we only create the\n        // template for the purpose of supporting `prepareAdoptedCssText`,\n        // which doesn't support @apply at all.\n        window.ShadyCSS!.prepareTemplateStyles(templateElement, scopeName);\n        return;\n      }\n      const condensedStyle = document.createElement('style');\n      // Collect styles into a single style. This helps us make sure ShadyCSS\n      // manipulations will not prevent us from being able to fix up template\n      // part indices.\n      // NOTE: collecting styles is inefficient for browsers but ShadyCSS\n      // currently does this anyway. When it does not, this should be changed.\n      for (let i = 0; i < length; i++) {\n        const style = styles[i];\n        style.parentNode!.removeChild(style);\n        condensedStyle.textContent! += style.textContent;\n      }\n      // Remove styles from nested templates in this scope.\n      removeStylesFromLitTemplates(scopeName);\n      // And then put the condensed style into the \"root\" template passed in as\n      // `template`.\n      const content = templateElement.content;\n      if (!!template) {\n        insertNodeIntoTemplate(template, condensedStyle, content.firstChild);\n      } else {\n        content.insertBefore(condensedStyle, content.firstChild);\n      }\n      // Note, it's important that ShadyCSS gets the template that `lit-html`\n      // will actually render so that it can update the style inside when\n      // needed (e.g. @apply native Shadow DOM case).\n      window.ShadyCSS!.prepareTemplateStyles(templateElement, scopeName);\n      const style = content.querySelector('style');\n      if (window.ShadyCSS!.nativeShadow && style !== null) {\n        // When in native Shadow DOM, ensure the style created by ShadyCSS is\n        // included in initially rendered output (`renderedDOM`).\n        renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);\n      } else if (!!template) {\n        // When no style is left in the template, parts will be broken as a\n        // result. To fix this, we put back the style node ShadyCSS removed\n        // and then tell lit to remove that node from the template.\n        // There can be no style in the template in 2 cases (1) when Shady DOM\n        // is in use, ShadyCSS removes all styles, (2) when native Shadow DOM\n        // is in use ShadyCSS removes the style if it contains no content.\n        // NOTE, ShadyCSS creates its own style so we can safely add/remove\n        // `condensedStyle` here.\n        content.insertBefore(condensedStyle, content.firstChild);\n        const removes = new Set<Node>();\n        removes.add(condensedStyle);\n        removeNodesFromTemplate(template, removes);\n      }\n    };\n\nexport interface ShadyRenderOptions extends Partial<RenderOptions> {\n  scopeName: string;\n}\n\n/**\n * Extension to the standard `render` method which supports rendering\n * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)\n * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used\n * or when the webcomponentsjs\n * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.\n *\n * Adds a `scopeName` option which is used to scope element DOM and stylesheets\n * when native ShadowDOM is unavailable. The `scopeName` will be added to\n * the class attribute of all rendered DOM. In addition, any style elements will\n * be automatically re-written with this `scopeName` selector and moved out\n * of the rendered DOM and into the document `<head>`.\n *\n * It is common to use this render method in conjunction with a custom element\n * which renders a shadowRoot. When this is done, typically the element's\n * `localName` should be used as the `scopeName`.\n *\n * In addition to DOM scoping, ShadyCSS also supports a basic shim for css\n * custom properties (needed only on older browsers like IE11) and a shim for\n * a deprecated feature called `@apply` that supports applying a set of css\n * custom properties to a given location.\n *\n * Usage considerations:\n *\n * * Part values in `<style>` elements are only applied the first time a given\n * `scopeName` renders. Subsequent changes to parts in style elements will have\n * no effect. Because of this, parts in style elements should only be used for\n * values that will never change, for example parts that set scope-wide theme\n * values or parts which render shared style elements.\n *\n * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a\n * custom element's `constructor` is not supported. Instead rendering should\n * either done asynchronously, for example at microtask timing (for example\n * `Promise.resolve()`), or be deferred until the first time the element's\n * `connectedCallback` runs.\n *\n * Usage considerations when using shimmed custom properties or `@apply`:\n *\n * * Whenever any dynamic changes are made which affect\n * css custom properties, `ShadyCSS.styleElement(element)` must be called\n * to update the element. There are two cases when this is needed:\n * (1) the element is connected to a new parent, (2) a class is added to the\n * element that causes it to match different custom properties.\n * To address the first case when rendering a custom element, `styleElement`\n * should be called in the element's `connectedCallback`.\n *\n * * Shimmed custom properties may only be defined either for an entire\n * shadowRoot (for example, in a `:host` rule) or via a rule that directly\n * matches an element with a shadowRoot. In other words, instead of flowing from\n * parent to child as do native css custom properties, shimmed custom properties\n * flow only from shadowRoots to nested shadowRoots.\n *\n * * When using `@apply` mixing css shorthand property names with\n * non-shorthand names (for example `border` and `border-width`) is not\n * supported.\n */\nexport const render =\n    (result: unknown,\n     container: Element|DocumentFragment|ShadowRoot,\n     options: ShadyRenderOptions) => {\n      if (!options || typeof options !== 'object' || !options.scopeName) {\n        throw new Error('The `scopeName` option is required.');\n      }\n      const scopeName = options.scopeName;\n      const hasRendered = parts.has(container);\n      const needsScoping = compatibleShadyCSSVersion &&\n          container.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */ &&\n          !!(container as ShadowRoot).host;\n      // Handle first render to a scope specially...\n      const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);\n      // On first scope render, render into a fragment; this cannot be a single\n      // fragment that is reused since nested renders can occur synchronously.\n      const renderContainer =\n          firstScopeRender ? document.createDocumentFragment() : container;\n      litRender(\n          result,\n          renderContainer,\n          {templateFactory: shadyTemplateFactory(scopeName), ...options} as\n              RenderOptions);\n      // When performing first scope render,\n      // (1) We've rendered into a fragment so that there's a chance to\n      // `prepareTemplateStyles` before sub-elements hit the DOM\n      // (which might cause them to render based on a common pattern of\n      // rendering in a custom element's `connectedCallback`);\n      // (2) Scope the template with ShadyCSS one time only for this scope.\n      // (3) Render the fragment into the container and make sure the\n      // container knows its `part` is the one we just rendered. This ensures\n      // DOM will be re-used on subsequent renders.\n      if (firstScopeRender) {\n        const part = parts.get(renderContainer)!;\n        parts.delete(renderContainer);\n        // ShadyCSS might have style sheets (e.g. from `prepareAdoptedCssText`)\n        // that should apply to `renderContainer` even if the rendered value is\n        // not a TemplateInstance. However, it will only insert scoped styles\n        // into the document if `prepareTemplateStyles` has already been called\n        // for the given scope name.\n        const template = part.value instanceof TemplateInstance ?\n            part.value.template :\n            undefined;\n        prepareTemplateStyles(\n            scopeName, renderContainer as DocumentFragment, template);\n        removeNodes(container, container.firstChild);\n        container.appendChild(renderContainer);\n        parts.set(container, part);\n      }\n      // After elements have hit the DOM, update styling if this is the\n      // initial render to this container.\n      // This is needed whenever dynamic changes are made so it would be\n      // safest to do every render; however, this would regress performance\n      // so we leave it up to the user to call `ShadyCSS.styleElement`\n      // for dynamic changes.\n      if (!hasRendered && needsScoping) {\n        window.ShadyCSS!.styleElement((container as ShadowRoot).host);\n      }\n    };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}